var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GBCore","category":"page"},{"location":"#GBCore","page":"Home","title":"GBCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GBCore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GBCore]","category":"page"},{"location":"#GBCore.AbstractGB","page":"Home","title":"GBCore.AbstractGB","text":"Abstract super type for all GenomicBreeding.jl custom types\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.CV","page":"Home","title":"GBCore.CV","text":"Cross-validation struct\n\nContains genomic prediction cross-validation details.\n\nFields\n\nreplication: replication name\nfold: fold name\nfit: genomic prediction model fit on the training set\nvalidation_populations: vector of validation populations corresponding to each validation entry\nvalidation_entries: corresponding vector of entries in the validation population/s\nvalidation_y_true: corresponding vector of observed phenotypes in the validation population/s\nvalidation_y_pred: corresponding vector of predicted phenotypes in the validation population/s\nmetrics: dictionary of genomic prediction accuracy metrics on the validation population/s\n\nConstructor\n\nUses the default contructor.\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Fit","page":"Home","title":"GBCore.Fit","text":"Genomic prediction model fit\n\nContains genomic prediction model fit details.\n\nFields\n\nmodel: name of the genomic prediction model used\nb_hat_labels: names of the loci-alleles used\nb_hat: effects of the loci-alleles\ntrait: name of the trait\nentries: names of the entries used in the current cross-validation replication and fold\npopulations: names of the populations used in the current cross-validation replication and fold\ny_true: corresponding observed phenotype values\ny_pred: corresponding predicted phenotype values\nmetrics: dictionary of genomic prediction accuracy metrics, inluding Pearson's correlation, mean absolute error and root mean-squared error\n\nConstructor\n\nFit(; n=1, l=10)\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Genomes","page":"Home","title":"GBCore.Genomes","text":"Genomes struct\n\nContaines unique entries and loci_alleles where allele frequencies can have missing values\n\nConstructor\n\nGenomes(; n::Int64 = 1, p::Int64 = 2)\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\nloci_alleles: names of the p loci-alleles combinations (p = l loci x a-1 alleles) including the \n\nchromsome or scaffold name, position, all alleles, and current allele separated by tabs (\"\\t\")\n\nallele_frequencies: n x p matrix of allele frequencies between 0 and 1 which can have missing values\nmask: n x p matrix of boolean mask for selective analyses and slicing\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2)\nGenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\njulia> fieldnames(Genomes)\n(:entries, :populations, :loci_alleles, :allele_frequencies, :mask)\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.populations = [\"pop_1\", \"pop_1\"];\n\njulia> genomes.loci_alleles = [\"chr1\\t12345\\tA|T\\tA\", \"chr2\\t678910\\tC|D\\tD\"];\n\njulia> genomes.allele_frequencies = [0.5 0.25; 0.9 missing];\n\njulia> genomes.mask = [true true; true false];\n\njulia> genomes\nGenomes([\"entry_1\", \"entry_2\"], [\"pop_1\", \"pop_1\"], [\"chr1\\t12345\\tA|T\\tA\", \"chr2\\t678910\\tC|D\\tD\"], Union{Missing, Float64}[0.5 0.25; 0.9 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Phenomes","page":"Home","title":"GBCore.Phenomes","text":"Phenomes struct\n\nConstains unique entries and traits where phenotype data can have missing values\n\nConstructor\n\nPhenomes(; n::Int64 = 1, t::Int64 = 2)\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\ntraits: names of the t traits\nphenotypes: n x t matrix of numeric (R) phenotype data which can have missing values\nmask: n x t matrix of boolean mask for selective analyses and slicing\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2)\nPhenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\njulia> fieldnames(Phenomes)\n(:entries, :populations, :traits, :phenotypes, :mask)\n\njulia> phenomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> phenomes.populations = [\"pop_A\", \"pop_B\"];\n\njulia> phenomes.traits = [\"height\", \"yield\"];\n\njulia> phenomes.phenotypes = [200.0 2.5; 150.0 missing];\n\njulia> phenomes.mask = [true true; true false];\n\njulia> phenomes\nPhenomes([\"entry_1\", \"entry_2\"], [\"pop_A\", \"pop_B\"], [\"height\", \"yield\"], Union{Missing, Float64}[200.0 2.5; 150.0 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.SimulatedEffects","page":"Home","title":"GBCore.SimulatedEffects","text":"SimulatedEffects struct\n\nContains:\n\nIdentification, i.e. trait, year, season, harvest, site, and replication\nAdditive environmental effects:\nyear\nseason\nsite\nEnvironmental interaction effects:\nseasonsxyear\nharvestsxseasonxyear\nsitesxharvestxseasonxyear\nSpatial effects including the field layout per year-season-harvest-site combination\nfield_layout\nreplicationsxsitexharvestxseasonxyear\nblocksxsitexharvestxseasonxyear\nrowsxsitexharvestxseasonxyear\ncolsxsitexharvestxseasonxyear\nGenetic effects\nadditive_genetic\ndominance_genetic\nepistasis_genetic\nGxE effects\nadditiveallelexsitexharvestxseasonx_year\ndominanceallelexsitexharvestxseasonx_year\nepistasisallelexsitexharvestxseasonx_year\n\nConstructor\n\nSimulatedEffects()\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.TEBV","page":"Home","title":"GBCore.TEBV","text":"Trial-estimate breeding values (TEBV) struct\n\nContains trial-estimated breeding values as generated by analyse(trials::Trials, ...).\n\nFields\n\ntraits: names of the traits t traits\nformulae: best-fitting formula for each trait\nmodels: best-fitting linear mixed model for each trait\ndf_BLUEs: vector of data frames of best linear unbiased estimators or fixed effects table of each best fitting model\ndf_BLUPs: vector of data frames of best linear unbiased predictors or random effects table of each best fitting model\nphenomes: vector of Phenomes structs each containing the breeding values\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1, t=1)]);\n\njulia> tebv.traits\n1-element Vector{String}:\n \"\"\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Trials","page":"Home","title":"GBCore.Trials","text":"Trials struct\n\nContains phenotype data across years, seasons, harvest, sites, populations, replications, blocks, rows, and columns\n\nConstructor\n\nTrials(; n::Int64 = 2, p::Int64 = 2)\n\nFields\n\nphenotypes: n x t matrix of numeric phenotype data which can have missing values\ntraits: names of the traits t traits\nyears: names of the years corresponding to each row in the phenotype matrix\nseasons: names of the seasons corresponding to each row in the phenotype matrix\nharvests: names of the harvests corresponding to each row in the phenotype matrix\nsites: names of the sites corresponding to each row in the phenotype matrix\nreplications: names of the replications corresponding to each row in the phenotype matrix\nblocks: names of the blocks corresponding to each row in the phenotype matrix\nrows: names of the rows corresponding to each row in the phenotype matrix\ncols: names of the cols corresponding to each row in the phenotype matrix\nentries: names of the entries corresponding to each row in the phenotype matrix\npopulations: names of the populations corresponding to each row in the phenotype matrix\n\nExamples\n\njulia> trials = Trials(n=1, t=2)\nTrials(Union{Missing, Float64}[missing missing], [\"\", \"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"])\n\njulia> fieldnames(Trials)\n(:phenotypes, :traits, :years, :seasons, :harvests, :sites, :replications, :blocks, :rows, :cols, :entries, :populations)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{CV, CV}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::CV, y::CV)::Bool\n\nEquality of CV structs using the hash function defined for CV structs.\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> cv_2 = clone(cv_1);\n\njulia> cv_3 = clone(cv_1); cv_3.replication = \"other_replication\";\n\njulia> cv_1 == cv_2\ntrue\n\njulia> cv_1 == cv_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Fit, Fit}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::Fit, y::Fit)::Bool\n\nEquality of Fit structs using the hash function defined for Fit structs.\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=4);\n\njulia> fit_2 = Fit(n=1, l=4);\n\njulia> fit_3 = Fit(n=1, l=2);\n\njulia> fit_1 == fit_2\ntrue\n\njulia> fit_1 == fit_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Genomes, Genomes}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::Genomes, y::Genomes)::Bool\n\nEquality of Genomes structs using the hash function defined for Genomes structs.\n\nExamples\n\njulia> genomes_1 = genomes = Genomes(n=2,p=4);\n\njulia> genomes_2 = genomes = Genomes(n=2,p=4);\n\njulia> genomes_3 = genomes = Genomes(n=1,p=2);\n\njulia> genomes_1 == genomes_2\ntrue\n\njulia> genomes_1 == genomes_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Phenomes, Phenomes}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::Phenomes, y::Phenomes)::Bool\n\nEquality of Phenomes structs using the hash function defined for Phenomes structs.\n\nExamples\n\njulia> phenomes_1 = phenomes = Phenomes(n=2, t=4);\n\njulia> phenomes_2 = phenomes = Phenomes(n=2, t=4);\n\njulia> phenomes_3 = phenomes = Phenomes(n=1, t=2);\n\njulia> phenomes_1 == phenomes_2\ntrue\n\njulia> phenomes_1 == phenomes_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::SimulatedEffects, y::SimulatedEffects)::Bool\n\nEquality of SimulatedEffects structs using the hash function defined for SimulatedEffects structs.\n\nExamples\n\njulia> effects_1 = SimulatedEffects();\n\njulia> effects_2 = SimulatedEffects();\n\njulia> effects_3 = SimulatedEffects(); effects_3.id[1] = \"SOMETHING_ELSE\";\n\njulia> effects_1 == effects_2\ntrue\n\njulia> effects_1 == effects_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{TEBV, TEBV}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::TEBV, y::TEBV)::Bool\n\nEquality of TEBV structs using the hash function defined for TEBV structs.\n\nExamples\n\njulia> tebv_1 = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_2 = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_3 = TEBV(traits=[\"SOMETHING_ELSE\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_1 == tebv_2\ntrue\n\njulia> tebv_1 == tebv_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Trials, Trials}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::Trials, y::Trials)::Bool\n\nEquality of Trials structs using the hash function defined for Trials structs.\n\nExamples\n\njulia> trials_1 = trials = Trials(n=2, t=4);\n\njulia> trials_2 = trials = Trials(n=2, t=4);\n\njulia> trials_3 = trials = Trials(n=1, t=2);\n\njulia> trials_1 == trials_2\ntrue\n\njulia> trials_1 == trials_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Genomes, Float64}","page":"Home","title":"Base.filter","text":"filter(\n    genomes::Genomes;\n    maf::Float64,\n    max_entry_sparsity::Float64 = 0.0,\n    max_locus_sparsity::Float64 = 0.0,\n    chr_pos_allele_ids::Union{Missing,Vector{String}} = missing,\n)::Genomes\n\nFilter a Genomes struct by minimum allele frequency, entries sparsity, loci sparsity, and/or vector of locus-allele names\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> filtered_genomes_1 = filter(genomes, 0.1);\n\njulia> filtered_genomes_2 = filter(genomes, 0.1, chr_pos_allele_ids=genomes.loci_alleles[1:1000]);\n\njulia> size(genomes.allele_frequencies)\n(100, 3000)\n\njulia> size(filtered_genomes_1.allele_frequencies)\n(100, 1236)\n\njulia> size(filtered_genomes_2.allele_frequencies)\n(100, 388)\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Genomes}","page":"Home","title":"Base.filter","text":"filter(genomes::Genomes)::Genomes\n\nFilter a Genomes struct using its mask matrix where all rows and columns with at least one false value are excluded\n\nExamples\n\njulia> genomes = simulategenomes(verbose=false); genomes.mask[1:10, 42:100] .= false;\n    \njulia> filtered_genomes = filter(genomes);\n\njulia> size(filtered_genomes.allele_frequencies)\n(90, 9941)\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Phenomes}","page":"Home","title":"Base.filter","text":"filter(phenomes::Phenomes)::Phenomes\n\nFilter a Phenomes struct using its mask matrix where all rows and columns with at least one false value are excluded\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> phenomes.mask .= true; phenomes.mask[6:10, 1] .= false;\n    \njulia> filtered_phenomes = filter(phenomes);\n\njulia> size(filtered_phenomes.phenotypes)\n(5, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{CV, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::CV, h::UInt)::UInt\n\nHash a CV struct using the entries, populations and locialleles. We deliberately excluded the allelefrequencies, and mask for efficiency.\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> typeof(hash(cv))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Fit, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Fit, h::UInt)::UInt\n\nHash a Fit struct using the entries, populations and locialleles. We deliberately excluded the allelefrequencies, and mask for efficiency.\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> typeof(hash(fit))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Genomes, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Genomes, h::UInt)::UInt\n\nHash a Genomes struct using the entries, populations and locialleles. We deliberately excluded the allelefrequencies, and mask for efficiency.\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2);\n\njulia> typeof(hash(genomes))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Phenomes, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Phenomes, h::UInt)::UInt\n\nHash a Phenomes struct.\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2);\n\njulia> typeof(hash(phenomes))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{SimulatedEffects, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::SimulatedEffects, h::UInt)::UInt\n\nHash a SimulatedEffects struct.\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> typeof(hash(effects))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{TEBV, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::TEBV, h::UInt)::UInt\n\nHash a TEBV struct using the traits, formualae and phenomes. We deliberately excluded the models, dfBLUEs, and dfBLUPs for efficiency.\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> typeof(hash(tebv))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Trials, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Trials, h::UInt)::UInt\n\nHash a Trials struct.\n\nExamples\n\njulia> trials = Trials(n=2, t=2);\n\njulia> typeof(hash(trials))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Genomes, Genomes}","page":"Home","title":"Base.merge","text":"merge(\n    genomes::Genomes,\n    other::Genomes;\n    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),\n    verbose::Bool = true,\n)::Genomes\n\nMerge two Genomes structs using a tuple of conflict resolution weights\n\nExamples\n\njulia> n = 100; l = 5_000; n_alleles = 2;\n\njulia> all = simulategenomes(n=n, l=l, n_alleles=n_alleles, verbose=false);\n\njulia> genomes = slice(all, idx_entries=collect(1:Int(floor(n*0.75))), idx_loci_alleles=collect(1:Int(floor(l*(n_alleles-1)*0.75))));\n\njulia> other = slice(all, idx_entries=collect(Int(floor(n*0.50)):n), idx_loci_alleles=collect(Int(floor(l*(n_alleles-1)*0.50)):l*(n_alleles-1)));\n\njulia> merged_genomes = merge(genomes, other, conflict_resolution=(0.75, 0.25), verbose=false);\n\njulia> size(merged_genomes.allele_frequencies)\n(100, 5000)\n\njulia> sum(ismissing.(merged_genomes.allele_frequencies))\n123725\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Genomes, Phenomes}","page":"Home","title":"Base.merge","text":"merge(genomes::Genomes, phenomes::Phenomes; keep_all::Bool=true)::Tuple{Genomes,Phenomes}\n\nMerge a Genomes struct with a Phenomes struct using union or intersection\n\nExamples\n\njulia> genomes = simulategenomes(n=10, verbose=false);\n\njulia> trials, effects = simulatetrials(genomes=slice(genomes, idx_entries=collect(1:5), idx_loci_alleles=collect(1:length(genomes.loci_alleles))), f_add_dom_epi=[0.90 0.05 0.05;], n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=2, verbose=false);\n\njulia> phenomes = Phenomes(n=5, t=1);\n\njulia> phenomes.entries = trials.entries[1:5];\n\njulia> phenomes.populations = trials.populations[1:5];\n\njulia> phenomes.traits = trials.traits;\n\njulia> phenomes.phenotypes = trials.phenotypes[1:5, :];\n\njulia> phenomes.mask .= true;\n\njulia> genomes_merged_1, phenomes_merged_1 = merge(genomes, phenomes, keep_all=true);\n\njulia> size(genomes_merged_1.allele_frequencies), size(phenomes_merged_1.phenotypes)\n((10, 10000), (10, 1))\n\njulia> genomes_merged_2, phenomes_merged_2 = merge(genomes, phenomes, keep_all=false);\n\njulia> size(genomes_merged_2.allele_frequencies), size(phenomes_merged_2.phenotypes)\n((5, 10000), (5, 1))\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Phenomes, Phenomes}","page":"Home","title":"Base.merge","text":"merge(\n    phenomes::Phenomes,\n    other::Phenomes;\n    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),\n    verbose::Bool = true,\n)::Phenomes\n\nMerge two Phenomes structs using a tuple of conflict resolution weights\n\nExamples\n\njulia> all = Phenomes(n=10, t=3); all.entries = string.(\"entry_\", 1:10); all.traits = [\"A\", \"B\", \"C\"]; all.phenotypes = rand(10,3);\n\njulia> phenomes = slice(all, idx_entries=collect(1:7), idx_traits=[1,2]);\n\njulia> other = slice(all, idx_entries=collect(5:10), idx_traits=[2,3]);\n\njulia> merged_phenomes = merge(phenomes, other, conflict_resolution=(0.75, 0.25), verbose=false);\n\njulia> size(merged_phenomes.phenotypes)\n(10, 3)\n\njulia> sum(ismissing.(merged_phenomes.phenotypes))\n7\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{SimulatedEffects}","page":"Home","title":"Base.sum","text":"sum(effects::SimulatedEffects)::Tuple{Int64, Int64, Int64}\n\nSum up the simulated effects to generate the simulated phenotype values\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> sum(effects)\n1-element Vector{Float64}:\n 0.0\n\njulia> effects.additive_genetic[1] = pi;\n\njulia> sum(effects)\n1-element Vector{Float64}:\n 3.141592653589793\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.addcompositetrait-Tuple{Phenomes}","page":"Home","title":"GBCore.addcompositetrait","text":"addcompositetrait(phenomes::Phenomes; composite_trait_name::String, formula_string::String)::Phenomes\n\nAdd a composite trait from existing traits in a Phenomes struct\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3);\n\njulia> phenomes_new = addcompositetrait(phenomes, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"A\");\n\njulia> phenomes_new.phenotypes[:, end] == phenomes.phenotypes[:, 1]\ntrue\n\njulia> phenomes_new = addcompositetrait(phenomes, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"(A^B) + (C/A) - sqrt(abs(B-A)) + log(1.00 + C)\");\n\njulia> phenomes_new.phenotypes[:, end] == (phenomes.phenotypes[:,1].^phenomes.phenotypes[:,2]) .+ (phenomes.phenotypes[:,3]./phenomes.phenotypes[:,1]) .- sqrt.(abs.(phenomes.phenotypes[:,2].-phenomes.phenotypes[:,1])) .+ log.(1.00 .+ phenomes.phenotypes[:,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.addcompositetrait-Tuple{Trials}","page":"Home","title":"GBCore.addcompositetrait","text":"addcompositetrait(trials::Trials; composite_trait_name::String, formula_string::String)::Trials\n\nAdd a composite trait from existing traits in a Trials struct\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> trials_new = addcompositetrait(trials, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"trait_1\");\n\njulia> trials_new.phenotypes[:, end] == trials.phenotypes[:, 1]\ntrue\n\njulia> trials_new = addcompositetrait(trials, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"(trait_1^(trait_2/100)) + (trait_3/trait_1) - sqrt(abs(trait_2-trait_1)) + log(1.00 + trait_3)\");\n\njulia> trials_new.phenotypes[:, end] == (trials.phenotypes[:,1].^(trials.phenotypes[:,2]/100)) .+ (trials.phenotypes[:,3]./trials.phenotypes[:,1]) .- sqrt.(abs.(trials.phenotypes[:,2].-trials.phenotypes[:,1])) .+ log.(1.00 .+ trials.phenotypes[:,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.analyse","page":"Home","title":"GBCore.analyse","text":"analyse(\n    trials::Trials,\n    formula_string::String = \"\";\n    traits::Union{Nothing,Vector{String}} = nothing,\n    max_levels::Int64 = 100,\n    max_time_per_model::Int64 = 60,\n    covariates_continuous::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = true,\n)::TEBV\n\nAnalyse trials\n\nArguments\n\ntrials: Trials struct \nmax_levels: maximum number of non-entry factor levels to include in the linear mixed models (default = 100)\nmax_time_per_model: maximum time in seconds for fitting each linear mixed model (default = 60)\nverbose: Show trials analysis progress bar? (default = true)\n\nOutputs\n\nTEBV struct containing the trait names, the best fitting formulae, models, BLUEs, and BLUPs for each trait\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);\n\njulia> tebv_1 = analyse(trials, \"trait_1 ~ 1 + (1|entries)\", max_levels=50, verbose=false);\n\njulia> tebv_1.traits\n3-element Vector{String}:\n \"trait_1\"\n \"trait_2\"\n \"trait_3\"\n\njulia> tebv_2 = analyse(trials, max_levels=50, verbose=false);\n\njulia> mean(tebv_2.phenomes[1].phenotypes) < mean(tebv_2.phenomes[2].phenotypes)\ntrue\n\njulia> trials = addcompositetrait(trials, composite_trait_name = \"covariate\", formula_string = \"(trait_1 + trait_2) / (trait_3 + 0.0001)\");\n\njulia> tebv_3 = Suppressor.@suppress analyse(trials, \"y ~ 1 + covariate + entries + (1|blocks)\", max_levels=50, verbose=false);\n\njulia> mean(tebv_3.phenomes[1].phenotypes) < mean(tebv_3.phenomes[2].phenotypes)\ntrue\n\njulia> tebv_4 = Suppressor.@suppress analyse(trials, max_levels=50, covariates_continuous=[\"covariate\"], verbose=false);\n\njulia> mean(tebv_4.phenomes[1].phenotypes) < mean(tebv_4.phenomes[2].phenotypes)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.analyse-Tuple{DataFrames.DataFrame}","page":"Home","title":"GBCore.analyse","text":"analyse(\n    df::DataFrame; \n    formulae::Vector{String},\n    idx_parallel_models::Vector{Int64},\n    idx_iterative_models::Vector{Int64},\n    max_time_per_model::Int64 = 60,\n    verbose::Bool=false)::Tuple{String, Any, DataFrame, DataFrame, Phenomes}\n\nFit univarite (one trait) linear mixed models to extract the effects of the entries the best fitting model.\n\nWe have the following guiding principles:\n\nAvoid over-parameterisation we'll have enough of that with the genomic prediction models\nWe will fit mixed models with unstructure variance-covariance matrix of the random effects\nWe prefer REML over ML\nWe compare BLUEs vs BLUPs of entries\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> formulae, n_levels = trialsmodelsfomulae!(df; trait = \"trait_1\", max_levels = 10);\n\njulia> idx_parallel_models::Vector{Int64} = findall(n_levels .<= (15));\n\njulia> idx_iterative_models::Vector{Int64} = findall((n_levels .<= (15)) .!= true);\n\njulia> formula_string, model, df_BLUEs, df_BLUPs, phenomes = analyse(df, formulae=formulae, idx_parallel_models=idx_parallel_models, idx_iterative_models=idx_iterative_models);\n\njulia> length(phenomes.entries) == length(unique(df.entries))\ntrue\n\njulia> df_2 = df[(df.years .== df.years[1]) .&& (df.harvests .== df.harvests[1]) .&& (df.seasons .== df.seasons[1]) .&& (df.sites .== df.sites[1]) .&& (df.replications .== df.replications[1]), :];\n\njulia> formula_string_2, model_2, df_BLUEs_2, df_BLUPs_2, phenomes_2 = analyse(df_2, formulae=[\"trait_1 ~ 1 + 1|entries\"]);\n\njulia> cor(phenomes_2.phenotypes[sortperm(phenomes_2.entries),1], df_2.trait_1[sortperm(df_2.entries)]) > 0.99\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{CV}","page":"Home","title":"GBCore.checkdims","text":"checkdims(cv::CV)::Bool\n\nCheck dimension compatibility of the fields of the CV struct\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> checkdims(cv)\ntrue\n\njulia> cv.validation_y_true = [0.0, 0.0];\n\njulia> checkdims(cv)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Fit}","page":"Home","title":"GBCore.checkdims","text":"checkdims(fit::Fit)::Bool\n\nCheck dimension compatibility of the fields of the Fit struct\n\nExamples\n\njulia> fit = Fit(n=1, l=4);\n\njulia> checkdims(fit)\ntrue\n\njulia> fit.b_hat_labels = [\"chr1\\t1\\tA|T\\tA\"];\n\njulia> checkdims(fit)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Genomes}","page":"Home","title":"GBCore.checkdims","text":"checkdims(genomes::Genomes)::Bool\n\nCheck dimension compatibility of the fields of the Genomes struct\n\nExamples\n\njulia> genomes = Genomes(n=2,p=4);\n\njulia> checkdims(genomes)\nfalse\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.loci_alleles = [\"chr1\\t1\\tA|T\\tA\", \"chr1\\t2\\tC|G\\tG\", \"chr2\\t3\\tA|T\\tA\", \"chr2\\t4\\tG|T\\tG\"];\n\njulia> checkdims(genomes)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Phenomes}","page":"Home","title":"GBCore.checkdims","text":"checkdims(y::Phenomes)::Bool\n\nCheck dimension compatibility of the fields of the Phenomes struct\n\nExamples\n\njulia> y = Phenomes(n=2, t=2);\n\njulia> checkdims(y)\nfalse\n\njulia> y.entries = [\"entry_1\", \"entry_2\"];\n\njulia> y.traits = [\"trait_1\", \"trait_2\"];\n\njulia> checkdims(y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{SimulatedEffects}","page":"Home","title":"GBCore.checkdims","text":"checkdims(effects::SimulatedEffects)::Bool\n\nCheck dimension compatibility of the fields of the SimulatedEffects struct\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> checkdims(effects)\ntrue\n\njulia> effects.id = [\"beaking_change\"];\n\njulia> checkdims(effects)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{TEBV}","page":"Home","title":"GBCore.checkdims","text":"checkdims(y::TEBV)::Bool\n\nCheck dimension compatibility of the fields of the TEBV struct\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> checkdims(tebv)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Trials}","page":"Home","title":"GBCore.checkdims","text":"checkdims(trials::Trials)::Bool\n\nCheck dimension compatibility of the fields of the Trials struct\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"]; trials.traits = [\"trait_1\", \"trait_2\"];\n\njulia> checkdims(trials)\ntrue\n\njulia> trials.entries = [\"entering_2_entries\", \"instead_of_just_1\"];\n\njulia> checkdims(trials)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{CV}","page":"Home","title":"GBCore.clone","text":"clone(x::CV)::CV\n\nClone a CV object\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> copy_cv = clone(cv)\nCV(\"replication_1\", \"fold_1\", Fit(\"\", [\"\", \"\"], [0.0, 0.0], \"\", [\"\"], [\"\"], [0.0], [0.0], Dict(\"\" => 0.0)), [\"population_1\"], [\"entry_1\"], [0.0], [0.0], Dict(\"\" => 0.0))\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Fit}","page":"Home","title":"GBCore.clone","text":"clone(x::Fit)::Fit\n\nClone a Fit object\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> copy_fit = clone(fit)\nFit(\"\", [\"\", \"\"], [0.0, 0.0], \"\", [\"\"], [\"\"], [0.0], [0.0], Dict(\"\" => 0.0))\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Genomes}","page":"Home","title":"GBCore.clone","text":"clone(x::Genomes)::Genomes\n\nClone a Genomes object\n\nExample\n\njulia> genomes = Genomes(n=2, p=2);\n\njulia> copy_genomes = clone(genomes)\nGenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Phenomes}","page":"Home","title":"GBCore.clone","text":"clone(x::Phenomes)::Phenomes\n\nClone a Phenomes object\n\nExample\n\njulia> phenomes = Phenomes(n=2, t=2);\n\njulia> copy_phenomes = clone(phenomes)\nPhenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{TEBV}","page":"Home","title":"GBCore.clone","text":"clone(x::TEBV)::TEBV\n\nClone a TEBV object\n\nExample\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> copy_tebv = clone(tebv);\n\njulia> copy_tebv.traits == tebv.traits\ntrue\n\njulia> copy_tebv.phenomes == tebv.phenomes\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Trials}","page":"Home","title":"GBCore.clone","text":"clone(x::Trials)::Trials\n\nClone a Trials object\n\nExample\n\njulia> trials = Trials(n=2, t=2);\n\njulia> copy_trials = clone(trials)\nTrials(Union{Missing, Float64}[missing missing; missing missing], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"])\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.countlevels-Tuple{DataFrames.DataFrame}","page":"Home","title":"GBCore.countlevels","text":"countlevels(df::DataFrame; column_names::Vector{String})::Int64\n\nCount the total number of factor levels across the column names provided.\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{Genomes}","page":"Home","title":"GBCore.dimensions","text":"dimensions(genomes::Genomes)::Dict{String, Int64}\n\nCount the number of entries, populations, loci-alleles combination, loci, maximum number of alleles per locus, and number of missing data in the Genomes struct\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> dimensions(genomes)\nDict{String, Int64} with 7 entries:\n  \"n_entries\"      => 100\n  \"n_chr\"          => 7\n  \"n_loci\"         => 1000\n  \"n_loci_alleles\" => 3000\n  \"n_populations\"  => 1\n  \"n_missing\"      => 0\n  \"max_n_alleles\"  => 4\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{Phenomes}","page":"Home","title":"GBCore.dimensions","text":"dimensions(phenomes::Phenomes)::Dict{String, Int64}\n\nCount the number of entries, populations, and traits in the Phenomes struct\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> dimensions(phenomes)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 30\n  \"n_zeroes\"      => 30\n  \"n_nan\"         => 0\n  \"n_entries\"     => 10\n  \"n_traits\"      => 3\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{TEBV}","page":"Home","title":"GBCore.dimensions","text":"dimensions(tebv::TEBV)::Dict{String, Int64}\n\nCount the number of entries, populations, and traits in the TEBV struct\n\nExamples\n\njulia> tebv = TEBV(traits=[\"trait_1\"], formulae=[\"trait_1 ~ 1 + 1|entries\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> dimensions(tebv)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 1\n  \"n_zeroes\"      => 0\n  \"n_nan\"         => 0\n  \"n_entries\"     => 1\n  \"n_traits\"      => 1\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 1\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{Trials}","page":"Home","title":"GBCore.dimensions","text":"dimensions(trials::Trials)::Dict{String, Int64}\n\nCount the number of entries, populations, and traits in the Trials struct\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"]; trials.traits = [\"trait_1\", \"trait_2\"];\n\njulia> dimensions(trials)\nDict{String, Int64} with 16 entries:\n  \"n_zeroes\"       => 0\n  \"n_harvests\"     => 1\n  \"n_nan\"          => 0\n  \"n_entries\"      => 1\n  \"n_traits\"       => 2\n  \"n_seasons\"      => 1\n  \"n_rows\"         => 1\n  \"n_blocks\"       => 1\n  \"n_missing\"      => 2\n  \"n_inf\"          => 0\n  \"n_total\"        => 2\n  \"n_replications\" => 1\n  \"n_years\"        => 1\n  \"n_sites\"        => 1\n  \"n_cols\"         => 1\n  \"n_populations\"  => 1\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.distances-Tuple{Genomes}","page":"Home","title":"GBCore.distances","text":"distances(\n    genomes::Genomes; \n    distance_metrics::Vector{String}=[\"euclidean\", \"correlation\", \"mad\", \"rmsd\", \"χ²\"]\n    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,\n)::Tuple{Vector{String}, Vector{String}, Dict{String, Matrix{Float64}}}\n\nEstimate pairwise distances between loci_alleles and entries.  Sparsity leading to less than 2 pairs will yield -Inf values in the resulting matrices.  Matrices with how many pairs were used to estimate the distance and correlation matrices are also included as well as the locus-allele and entry names.\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> (loci_alleles, entries, dist) = distances(genomes, distance_metrics=[\"correlation\", \"χ²\"]);\n\njulia> sort(string.(keys(dist))) == [\"entries|correlation\", \"entries|counts\", \"entries|χ²\", \"loci_alleles|correlation\", \"loci_alleles|counts\", \"loci_alleles|χ²\"]\ntrue\n\njulia> C = dist[\"entries|correlation\"]; C[diagind(C)] == repeat([1], length(genomes.entries))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.distances-Tuple{Phenomes}","page":"Home","title":"GBCore.distances","text":"distances(\n    phenomes::Phenomes; \n    distance_metrics::Vector{String}=[\"euclidean\", \"correlation\", \"mad\", \"rmsd\", \"χ²\"],\n    standardise_traits::Bool = false,\n)::Tuple{String, Matrix{Float64}}Tuple{Vector{String}, Vector{String}, Dict{String, Matrix{Float64}}}\n\nEstimate pairwise distances between traits and entries.  Sparsity leading to less than 2 pairs will yield -Inf values in the resulting matrices.  Matrices with how many pairs were used to estimate the distance and correlation matrices are also included as well as the trait and entry names. Note that prior to computing correlations between entries, the phenotype matrix was standardised, i.e. each trait was transformed to have a mean of 0 and standard deviation of 1.\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[2,2] = missing;\n\njulia> (traits, entries, dist) = distances(phenomes, distance_metrics=[\"correlation\", \"χ²\"]);\n\njulia> sort(string.(keys(dist))) == [\"entries|correlation\", \"entries|counts\", \"entries|χ²\", \"traits|correlation\", \"traits|counts\", \"traits|χ²\"]\ntrue\n\njulia> C = dist[\"entries|correlation\"]; C[diagind(C)] == repeat([1], length(phenomes.entries))\ntrue\n\njulia> dist[\"traits|counts\"][:, 2] == dist[\"traits|counts\"][2, :] == repeat([9], length(phenomes.traits))\ntrue\n\njulia> dist[\"entries|counts\"][:, 2] == dist[\"entries|counts\"][2, :] == repeat([2], length(phenomes.entries))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.extractphenomes-Tuple{TEBV}","page":"Home","title":"GBCore.extractphenomes","text":"extractphenomes(tebv::TEBV)::Phenomes\n\nExtract Phenomes from TEBV\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);\n\njulia> tebv = analyse(trials, max_levels=50, verbose=false);\n\njulia> phenomes = extractphenomes(tebv);\n\njulia> phenomes.traits == [\"trait_1\", \"trait_2\", \"trait_3\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.extractphenomes-Tuple{Trials}","page":"Home","title":"GBCore.extractphenomes","text":"extractphenomes(trials::Trials)::Phenomes\n\nExtract Phenomes from Trials struct. Each trait-by-environment variables combination make up the traits in the resulting Phenomes struct. The trait names start with trait name in Trials suffixed by the trait-by-environment variables combinations. If there is a single environment variables combination, then no suffix is added to the trait name.\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> size(phenomes.phenotypes)\n(100, 384)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.loci-Tuple{Genomes}","page":"Home","title":"GBCore.loci","text":"loci(genomes::Genomes)::Tuple{Vector{String},Vector{Int64},Vector{Int64},Vector{Int64}}\n\nExtract chromosome names, positions, start and end indexes of each locus across loci\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chromosomes, positions, loci_ini_idx, loci_fin_idx = loci(genomes);\n\njulia> length(chromosomes), length(positions), length(loci_ini_idx), length(loci_fin_idx)\n(1000, 1000, 1000, 1000)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.loci_alleles-Tuple{Genomes}","page":"Home","title":"GBCore.loci_alleles","text":"loci_alleles(genomes::Genomes)::Tuple{Vector{String},Vector{Int64},Vector{String}}\n\nExtract chromosomes, positions, and alleles across loci-allele combinations\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chromosomes, positions, alleles = loci_alleles(genomes);\n\njulia> length(chromosomes), length(positions), length(alleles)\n(3000, 3000, 3000)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.plot","page":"Home","title":"GBCore.plot","text":"plot(genomes::Genomes)::Nothing\n\nPlot allele frequencies\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> GBCore.plot(genomes)\n\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.plot-2","page":"Home","title":"GBCore.plot","text":"plot(fit::Fit, distribution::Any=[TDist(1), Normal()][1], α::Float64=0.05)\n\nManhattan plot\n\nExamples\n\njulia> distribution = [TDist(1), Normal()][2];\n\njulia> fit = Fit(n=100, l=10_000); fit.b_hat = rand(distribution, 10_000);  α = 0.05;\n\njulia> GBCore.plot(fit);\n\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.plot-Tuple{Phenomes}","page":"Home","title":"GBCore.plot","text":"plot(phenomes::Phenomes)::Nothing\n\nPlot histogram/s of the trait value/s and a heatmap of trait correlations\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3);\n\njulia> GBCore.plot(phenomes);\n\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.plot-Tuple{TEBV}","page":"Home","title":"GBCore.plot","text":"plot(tebv::TEBV)\n\nPlot TEBV output by plotting the resulting Phenomes struct\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.plot-Tuple{Trials}","page":"Home","title":"GBCore.plot","text":"plot(trials::Trials)::Nothing\n\nPlot histogram/s of the trait value/s and a heatmap of trait correlations across the entire trial. Additionally, plot mean trait values per year, season, harvest, site, replications, row, column, and population for each trait.\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> GBCore.plot(trials);\n\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulateeffects-Tuple{}","page":"Home","title":"GBCore.simulateeffects","text":"Simulate effects\n\nSample p x q effects from a multivariate normal distribution with μ~Exp(λ) and Σ=μμ'\n\nArguments\n\np: number of correlated effects to simulate (default = 2)\nq: number times to simulate the correlated effects from the same distribution (default = 1)\nλ: parameter of the exponential distritbution from which the means will be sampled from (default = 1.00)\nseed: randomisation seed (default = 42)\n\nOutput\n\np x q matrix of correlated effects\n\nExamples\n\njulia> θ::Matrix{Float64} = simulateeffects();\n\njulia> sum(abs.(θ - [-0.0886501800782904; -0.596478483888422])) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulategenomes-Tuple{}","page":"Home","title":"GBCore.simulategenomes","text":"Simulate genomes\n\nArguments\n\nn: number of entries (default = 100)\nl: number of loci (default = 10_000)\nn_chroms: number of chromosomes (default = 7)\nn_alleles: number of alleles per locus (default = 2)\nmax_pos: total length of the genome in base-pairs (bp) (default = 135000000)\nld_corr_50perc_kb: distance in bp at which linkage expressed as correlation between a pair of loci is at 50% (default = 1_000)\nμ_β_params: the shape parameters of the Beta distribution from which the mean allele frequencies will be sampled  (default = (0.5, 0.5); U-shaped distribution; you may use (2.0, 2.0) for a bell-shaped distribution)\nsparsity: Proportion of missing data (default = 0.0)\nseed: psuedo-random number generator seed for replicability (default = 42)\nverbose: Show progress bar and plot the linkage heatmap into an svg file? (default = true)\n\nOutput\n\nGenomes\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, verbose=false);\n\njulia> length(genomes.entries)\n100\n\njulia> length(genomes.populations)\n100\n\njulia> length(genomes.loci_alleles)\n20000\n\njulia> size(genomes.allele_frequencies)\n(100, 20000)\n\njulia> mean(ismissing.(genomes.allele_frequencies))\n0.0\n\njulia> rng::TaskLocalRNG = Random.seed!(123);\n\njulia> idx = StatsBase.sample(rng, range(1, 20_000, step=2), 250, replace = false, ordered = true);\n\njulia> correlations = StatsBase.cor(genomes.allele_frequencies[:, idx]);\n\njulia> correlations[10,10] == 1.00\ntrue\n\njulia> correlations[10,10] > correlations[10,250]\ntrue\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, sparsity=0.25, verbose=false);\n\njulia> mean(ismissing.(genomes.allele_frequencies))\n0.25\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulategenomiceffects-Tuple{}","page":"Home","title":"GBCore.simulategenomiceffects","text":"Simulate genomic effects\n\nSimulate additive, dominance, and epistatic effects\n\nArguments\n\ngenomes: Genome struct includes the n entries x p loci-alleles combinations (p = l loci x a-1 alleles)\nf_additive: proportion of the l loci with non-zero additive effects on the phenotype\nf_dominance: proportion of the l*f_additive additive effects loci with additional dominance effects\nf_epistasis: proportion of the l*f_additive additive effects loci with additional epistasis effects\n\nOutputs\n\nn x 3 matrix of additive, dominance and epistasis effects per entry\np x 3 matrix of additive, dominance and epistasis effects per locus-allele combination\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> G, B = simulategenomiceffects(genomes=genomes, f_additive=0.05, f_dominance=0.75, f_epistasis=0.25);\n\njulia> size.([G, B])\n2-element Vector{Tuple{Int64, Int64}}:\n (100, 3)\n (4000, 3)\n\njulia> sum(B .!= 0.0, dims=1)\n1×3 Matrix{Int64}:\n 200  75  50\n\nDetails\n\nThe additive, dominance, and epistasis allele effects share a common exponential distribution (λ=1) from which  the mean of the effects (μ) are sampled, and the covariance matrix is derived (Σ = μ * μ';  where if det(Σ)≈0 then we iteratively add 1.00 to the diagonals until it becomes invertible or 10 iterations  finishes and throws an error). The non-additive or epistasis allele effects were simulated by multiplying the allele  frequencies of all possible unique pairs of epistasis alleles and their effects.\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulatetrials-Tuple{}","page":"Home","title":"GBCore.simulatetrials","text":"Simulate trials\n\nArguments\n\ngenomes: Genome struct includes the n entries x p loci-alleles combinations (p = l loci x a-1 alleles)\nf_add_dom_epi: n_traits x 3 numeric matrix of loci proportion with additive, dominance and epistasis effects, i.e. each column refers to:\nf_additive: proportion of the l loci with non-zero additive effects on the phenotype\nf_dominance: proportion of the l*f_additive additive effects loci with additional dominance effects\nf_epistasis: proportion of the l*f_additive additive effects loci with additional epistasis effects\n(default = [0.01 0.25 0.10; 0.05 0.50 0.25; 0.10 0.25 0.00])\nn_years: Number of years (default = 2)\nn_seasons: Number of seasons (default = 4)\nn_harvests: Number of harvests (default = 2)\nn_sites: Number of sites (default = 4)\nn_replications: Number of replications (default = 2)\nn_blocks: Number of blocks across the entire field layout (default = missing)\nn_rows: Number of rows across the entire field layout (default = missing)\nn_cols: Number of columns across the entire field layout (default = missing)\nproportion_of_variance: 9 x n_traits numeric matrix of scaled/non-scaled proportion of variances allocated to   genetic and environmental effects (default = missing; values will be sampled from a uniform distribution  followed by a biased sample on the first row, i.e. additive effects row).  The rows correspond to the variance allocated to:\nadditive genetic effects\ndominance genetic effects\nepistasis genetic effects\nyears effects\nseasons effects\nsites effects\nenvironmental interactions\nspatial interactions\nGxE interactiions\nseed: Randomisation seed (default = 42)\nsparsity: Proportion of missing data (default = 0.0)\nverbose: Show trials simulation progress bar? (default = true)\n\nOutputs\n\nTrials struct of simulated phenotype data\nVector of SimulatedEffects each corresponding to each trait-year-season-harvest-site-replication combination\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> trials::Trials, vector_of_effects::Array{SimulatedEffects,1} = simulatetrials(genomes=genomes, sparsity=0.25, verbose=false);\n\njulia> size(trials.phenotypes)\n(12800, 3)\n\njulia> size(trials.traits)\n(3,)\n\njulia> unique(trials.entries) == genomes.entries\ntrue\n\njulia> unique(trials.populations) == unique(genomes.populations)\ntrue\n\njulia> abs(mean(ismissing.(trials.phenotypes)) - 0.25) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.slice-Tuple{Genomes}","page":"Home","title":"GBCore.slice","text":"slice(\n    genomes::Genomes; \n    idx_entries::Union{Nothing, Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,\n)::Genomes\n\nSlice a Genomes struct by specifing indixes of entries and loci-allele combinations\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> sliced_genomes = slice(genomes, idx_entries=collect(1:10); idx_loci_alleles=collect(1:300));\n\njulia> dimensions(sliced_genomes)\nDict{String, Int64} with 7 entries:\n  \"n_entries\"      => 10\n  \"n_chr\"          => 1\n  \"n_loci\"         => 100\n  \"n_loci_alleles\" => 300\n  \"n_populations\"  => 1\n  \"n_missing\"      => 0\n  \"max_n_alleles\"  => 4\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.slice-Tuple{Phenomes}","page":"Home","title":"GBCore.slice","text":"slice(\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing, Vector{Int64}} = nothing,\n    idx_traits::Union{Nothing, Vector{Int64}} = nothing,\n)::Phenomes\n\nSlice a Phenomes struct by specifing indexes of entries and traits\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> sliced_phenomes = slice(phenomes, idx_entries=collect(1:5); idx_traits=collect(2:3));\n\njulia> dimensions(sliced_phenomes)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 10\n  \"n_zeroes\"      => 10\n  \"n_nan\"         => 0\n  \"n_entries\"     => 5\n  \"n_traits\"      => 2\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.slice-Tuple{Trials}","page":"Home","title":"GBCore.slice","text":"slice(\n    trials::Trials; \n    traits::Union{Nothing, Vector{String}} = nothing,\n    populations::Union{Nothing, Vector{String}} = nothing,\n    entries::Union{Nothing, Vector{String}} = nothing,\n    years::Union{Nothing, Vector{String}} = nothing,\n    harvests::Union{Nothing, Vector{String}} = nothing,\n    seasons::Union{Nothing, Vector{String}} = nothing,\n    sites::Union{Nothing, Vector{String}} = nothing,\n    replications::Union{Nothing, Vector{String}} = nothing,\n    blocks::Union{Nothing, Vector{String}} = nothing,\n    rows::Union{Nothing, Vector{String}} = nothing,\n    cols::Union{Nothing, Vector{String}} = nothing,\n)::Trials\n\nSlice a Trials struct by specifing indexes of entries and traits\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> sliced_trials = slice(trials, traits=trials.traits[2:3], years=[unique(trials.years)[1]], seasons=unique(trials.seasons)[2:3]);\n\njulia> dimensions(sliced_trials)\nDict{String, Int64} with 16 entries:\n  \"n_zeroes\"       => 0\n  \"n_harvests\"     => 2\n  \"n_nan\"          => 0\n  \"n_entries\"      => 100\n  \"n_traits\"       => 2\n  \"n_seasons\"      => 2\n  \"n_blocks\"       => 10\n  \"n_rows\"         => 10\n  \"n_missing\"      => 0\n  \"n_inf\"          => 0\n  \"n_total\"        => 6400\n  \"n_replications\" => 2\n  \"n_years\"        => 1\n  \"n_sites\"        => 4\n  \"n_cols\"         => 20\n  \"n_populations\"  => 1\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.summarise-Tuple{Vector{CV}}","page":"Home","title":"GBCore.summarise","text":"summarise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}\n\nSummarise a vector of CV structs into:\n\na data frame of mean metrics, and\na data frame of mean and standard deviation of phenotype predictions per entry, trait and model.\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(\"cor\" => 0.0, \"rmse\" => 1.0); fit_1.trait = \"trait_1\";\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit_1, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit_1.metrics);\n\njulia> fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(\"cor\" => 1.0, \"rmse\" => 0.0); fit_2.trait = \"trait_1\";\n\njulia> cv_2 = CV(\"replication_2\", \"fold_2\", fit_2, [\"population_2\"], [\"entry_2\"], [0.0], [0.0], fit_2.metrics);\n\njulia> cvs = [cv_1, cv_2];\n\njulia> df_summary, df_summary_per_entry = summarise(cvs);\n\njulia> size(df_summary)\n(2, 8)\n\njulia> size(df_summary_per_entry)\n(2, 8)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.tabularise","page":"Home","title":"GBCore.tabularise","text":"tabularise(trials::Trials)::DataFrame\n\nExport the Trials structs into a DataFrames.DataFrame struct\n\nExamples\n\njulia> fit = Fit(n=100, l=10_000); fit.b_hat = rand(10_000); fit.model=\"some_model\"; fit.trait=\"some_trait\"; \n\njulia> fit.metrics = Dict(\"cor\" => rand(), \"rmse\" => rand()); fit.populations .= \"pop_1\";\n\njulia> df = tabularise(fit);\n\njulia> size(df)\n(10000, 6)\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.tabularise-Tuple{Phenomes}","page":"Home","title":"GBCore.tabularise","text":"tabularise(phenomes::Phenomes)::DataFrame\n\nExport the Phenomes structs into a DataFrames.DataFrame struct\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> tabularise(phenomes)\n10×6 DataFrame\n Row │ id     entries   populations  A         B         C        \n     │ Int64  String    String       Float64?  Float64?  Float64? \n─────┼────────────────────────────────────────────────────────────\n   1 │     1  entry_1   pop_1             0.0       0.0       0.0\n   2 │     2  entry_2   pop_1             0.0       0.0       0.0\n   3 │     3  entry_3   pop_1             0.0       0.0       0.0\n   4 │     4  entry_4   pop_1             0.0       0.0       0.0\n   5 │     5  entry_5   pop_1             0.0       0.0       0.0\n   6 │     6  entry_6   pop_1             0.0       0.0       0.0\n   7 │     7  entry_7   pop_1             0.0       0.0       0.0\n   8 │     8  entry_8   pop_1             0.0       0.0       0.0\n   9 │     9  entry_9   pop_1             0.0       0.0       0.0\n  10 │    10  entry_10  pop_1             0.0       0.0       0.0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.tabularise-Tuple{Trials}","page":"Home","title":"GBCore.tabularise","text":"tabularise(trials::Trials)::DataFrame\n\nExport the Trials structs into a DataFrames.DataFrame struct\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> size(df)\n(12800, 14)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.tabularise-Tuple{Vector{CV}}","page":"Home","title":"GBCore.tabularise","text":"tabularise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}\n\nExport a vector of CV structs into data frames of metrics across entries and per validation entry\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(\"cor\" => 0.0, \"rmse\" => 1.0); fit_1.trait = \"trait_1\";\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit_1, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit_1.metrics);\n\njulia> fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(\"cor\" => 1.0, \"rmse\" => 0.0); fit_2.trait = \"trait_1\";\n\njulia> cv_2 = CV(\"replication_2\", \"fold_2\", fit_2, [\"population_2\"], [\"entry_2\"], [0.0], [0.0], fit_2.metrics);\n\njulia> cvs = [cv_1, cv_2];\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> names(df_across_entries)\n10-element Vector{String}:\n \"training_population\"\n \"validation_population\"\n \"trait\"\n \"model\"\n \"replication\"\n \"fold\"\n \"training_size\"\n \"validation_size\"\n \"cor\"\n \"rmse\"\n\njulia> df_across_entries[!, [:cor, :rmse]]\n2×2 DataFrame\n Row │ cor      rmse    \n     │ Float64  Float64 \n─────┼──────────────────\n   1 │     0.0      1.0\n   2 │     1.0      0.0\n\njulia> names(df_per_entry)\n9-element Vector{String}:\n \"training_population\"\n \"validation_population\"\n \"entry\"\n \"trait\"\n \"model\"\n \"replication\"\n \"fold\"\n \"y_true\"\n \"y_pred\"\n\njulia> df_per_entry[!, [:entry, :y_true, :y_pred]]\n2×3 DataFrame\n Row │ entry    y_true   y_pred  \n     │ String   Float64  Float64 \n─────┼───────────────────────────\n   1 │ entry_1      0.0      0.0\n   2 │ entry_2      0.0      0.0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}","page":"Home","title":"GBCore.trialsmodelsfomulae!","text":"trialsmodelsfomulae!(df::DataFrame; trait::String, max_levels::Int64 = 100)::Vector{String}\n\nDefine formulae for the mixed models to fit on the tabularised Trials struct.     - appends interaction effects intto df     - returns:         + a vector of formulae as strings         + a vector of the total number of non-entry factor levels\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> size(df)\n(12800, 14)\n\njulia> formulae, n_levels = trialsmodelsfomulae!(df, trait=\"trait_1\");\n\njulia> size(df)\n(12800, 134)\n\njulia> length(formulae)\n76\n\njulia> sum(n_levels .== sort(n_levels))\n76\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.@string2formula-Tuple{Any}","page":"Home","title":"GBCore.@string2formula","text":"string2formula(x)\n\nMacro to Meta.parse a string into a formula. TODO: Refactor to make more idiomatic.\n\n\n\n\n\n","category":"macro"},{"location":"#GBCore.@stringevaluation-Tuple{Any}","page":"Home","title":"GBCore.@stringevaluation","text":"stringevaluation(x)\n\nMacro to Meta.parse a string of formula.\n\n\n\n\n\n","category":"macro"}]
}

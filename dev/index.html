<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GBCore.jl</title><meta name="title" content="Home · GBCore.jl"/><meta property="og:title" content="Home · GBCore.jl"/><meta property="twitter:title" content="Home · GBCore.jl"/><meta name="description" content="Documentation for GBCore.jl."/><meta property="og:description" content="Documentation for GBCore.jl."/><meta property="twitter:description" content="Documentation for GBCore.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GBCore.jl/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GBCore.jl/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GBCore.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GBCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBCore.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GBCore"><a class="docs-heading-anchor" href="#GBCore">GBCore</a><a id="GBCore-1"></a><a class="docs-heading-anchor-permalink" href="#GBCore" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/GenomicBreeding/GBCore.jl">GBCore</a>.</p><ul><li><a href="#GBCore.AbstractGB"><code>GBCore.AbstractGB</code></a></li><li><a href="#GBCore.CV"><code>GBCore.CV</code></a></li><li><a href="#GBCore.Fit"><code>GBCore.Fit</code></a></li><li><a href="#GBCore.Genomes"><code>GBCore.Genomes</code></a></li><li><a href="#GBCore.Phenomes"><code>GBCore.Phenomes</code></a></li><li><a href="#GBCore.SimulatedEffects"><code>GBCore.SimulatedEffects</code></a></li><li><a href="#GBCore.TEBV"><code>GBCore.TEBV</code></a></li><li><a href="#GBCore.Trials"><code>GBCore.Trials</code></a></li><li><a href="#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{TEBV, TEBV}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Genomes, Genomes}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{CV, CV}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Fit, Fit}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Phenomes, Phenomes}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Trials, Trials}"><code>Base.:==</code></a></li><li><a href="#Base.filter-Tuple{Genomes}"><code>Base.filter</code></a></li><li><a href="#Base.filter-Tuple{Phenomes}"><code>Base.filter</code></a></li><li><a href="#Base.filter-Tuple{Genomes, Float64}"><code>Base.filter</code></a></li><li><a href="#Base.hash-Tuple{Phenomes, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{TEBV, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{SimulatedEffects, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{CV, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Fit, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Trials, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Genomes, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.merge-Tuple{Phenomes, Phenomes}"><code>Base.merge</code></a></li><li><a href="#Base.merge-Tuple{Genomes, Phenomes}"><code>Base.merge</code></a></li><li><a href="#Base.merge-Tuple{Genomes, Genomes}"><code>Base.merge</code></a></li><li><a href="#Base.sum-Tuple{SimulatedEffects}"><code>Base.sum</code></a></li><li><a href="#GBCore.addcompositetrait-Tuple{Phenomes}"><code>GBCore.addcompositetrait</code></a></li><li><a href="#GBCore.addcompositetrait-Tuple{Trials}"><code>GBCore.addcompositetrait</code></a></li><li><a href="#GBCore.analyse"><code>GBCore.analyse</code></a></li><li><a href="#GBCore.analyse-Tuple{DataFrames.DataFrame}"><code>GBCore.analyse</code></a></li><li><a href="#GBCore.checkdims-Tuple{TEBV}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.checkdims-Tuple{Fit}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.checkdims-Tuple{Genomes}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.checkdims-Tuple{Trials}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.checkdims-Tuple{CV}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.checkdims-Tuple{Phenomes}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.checkdims-Tuple{SimulatedEffects}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.clone-Tuple{Trials}"><code>GBCore.clone</code></a></li><li><a href="#GBCore.clone-Tuple{Genomes}"><code>GBCore.clone</code></a></li><li><a href="#GBCore.clone-Tuple{CV}"><code>GBCore.clone</code></a></li><li><a href="#GBCore.clone-Tuple{Phenomes}"><code>GBCore.clone</code></a></li><li><a href="#GBCore.clone-Tuple{Fit}"><code>GBCore.clone</code></a></li><li><a href="#GBCore.clone-Tuple{TEBV}"><code>GBCore.clone</code></a></li><li><a href="#GBCore.countlevels-Tuple{DataFrames.DataFrame}"><code>GBCore.countlevels</code></a></li><li><a href="#GBCore.dimensions-Tuple{Phenomes}"><code>GBCore.dimensions</code></a></li><li><a href="#GBCore.dimensions-Tuple{Trials}"><code>GBCore.dimensions</code></a></li><li><a href="#GBCore.dimensions-Tuple{TEBV}"><code>GBCore.dimensions</code></a></li><li><a href="#GBCore.dimensions-Tuple{Genomes}"><code>GBCore.dimensions</code></a></li><li><a href="#GBCore.distances-Tuple{Genomes}"><code>GBCore.distances</code></a></li><li><a href="#GBCore.distances-Tuple{Phenomes}"><code>GBCore.distances</code></a></li><li><a href="#GBCore.extractphenomes-Tuple{TEBV}"><code>GBCore.extractphenomes</code></a></li><li><a href="#GBCore.extractphenomes-Tuple{Trials}"><code>GBCore.extractphenomes</code></a></li><li><a href="#GBCore.loci-Tuple{Genomes}"><code>GBCore.loci</code></a></li><li><a href="#GBCore.loci_alleles-Tuple{Genomes}"><code>GBCore.loci_alleles</code></a></li><li><a href="#GBCore.plot"><code>GBCore.plot</code></a></li><li><a href="#GBCore.plot"><code>GBCore.plot</code></a></li><li><a href="#GBCore.plot-Tuple{Trials}"><code>GBCore.plot</code></a></li><li><a href="#GBCore.plot-Tuple{TEBV}"><code>GBCore.plot</code></a></li><li><a href="#GBCore.plot-Tuple{Phenomes}"><code>GBCore.plot</code></a></li><li><a href="#GBCore.simulateeffects-Tuple{}"><code>GBCore.simulateeffects</code></a></li><li><a href="#GBCore.simulategenomes-Tuple{}"><code>GBCore.simulategenomes</code></a></li><li><a href="#GBCore.simulategenomiceffects-Tuple{}"><code>GBCore.simulategenomiceffects</code></a></li><li><a href="#GBCore.simulatetrials-Tuple{}"><code>GBCore.simulatetrials</code></a></li><li><a href="#GBCore.slice-Tuple{Phenomes}"><code>GBCore.slice</code></a></li><li><a href="#GBCore.slice-Tuple{Trials}"><code>GBCore.slice</code></a></li><li><a href="#GBCore.slice-Tuple{Genomes}"><code>GBCore.slice</code></a></li><li><a href="#GBCore.summarise-Tuple{Vector{CV}}"><code>GBCore.summarise</code></a></li><li><a href="#GBCore.tabularise-Tuple{Vector{CV}}"><code>GBCore.tabularise</code></a></li><li><a href="#GBCore.tabularise-Tuple{Phenomes}"><code>GBCore.tabularise</code></a></li><li><a href="#GBCore.tabularise-Tuple{Trials}"><code>GBCore.tabularise</code></a></li><li><a href="#GBCore.tabularise"><code>GBCore.tabularise</code></a></li><li><a href="#GBCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}"><code>GBCore.trialsmodelsfomulae!</code></a></li><li><a href="#GBCore.@string2formula-Tuple{Any}"><code>GBCore.@string2formula</code></a></li><li><a href="#GBCore.@stringevaluation-Tuple{Any}"><code>GBCore.@stringevaluation</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.AbstractGB" href="#GBCore.AbstractGB"><code>GBCore.AbstractGB</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGB</code></pre><p>The root abstract type for all core types in GenomicBreeding.jl package.</p><p>This type serves as the common ancestor for the type hierarchy in the package, enabling shared functionality and type-based dispatch across all derived types.</p><p><strong>Extended help</strong></p><p>All custom core types in GenomicBreeding.jl should subtype from <code>AbstractGB</code> to ensure consistency in the type system and to enable generic implementations of common operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.CV" href="#GBCore.CV"><code>GBCore.CV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Cross-validation struct</strong></p><p>Contains genomic prediction cross-validation details.</p><p><strong>Fields</strong></p><ul><li><code>replication</code>: replication name</li><li><code>fold</code>: fold name</li><li><code>fit</code>: genomic prediction model fit on the training set</li><li><code>validation_populations</code>: vector of validation populations corresponding to each validation entry</li><li><code>validation_entries</code>: corresponding vector of entries in the validation population/s</li><li><code>validation_y_true</code>: corresponding vector of observed phenotypes in the validation population/s</li><li><code>validation_y_pred</code>: corresponding vector of predicted phenotypes in the validation population/s</li><li><code>metrics</code>: dictionary of genomic prediction accuracy metrics on the validation population/s</li></ul><p><strong>Constructor</strong></p><p>Uses the default contructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L365-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.Fit" href="#GBCore.Fit"><code>GBCore.Fit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Genomic prediction model fit</strong></p><p>Contains genomic prediction model fit details.</p><p><strong>Fields</strong></p><ul><li><code>model</code>: name of the genomic prediction model used</li><li><code>b_hat_labels</code>: names of the loci-alleles used</li><li><code>b_hat</code>: effects of the loci-alleles</li><li><code>trait</code>: name of the trait</li><li><code>entries</code>: names of the entries used in the current cross-validation replication and fold</li><li><code>populations</code>: names of the populations used in the current cross-validation replication and fold</li><li><code>y_true</code>: corresponding observed phenotype values</li><li><code>y_pred</code>: corresponding predicted phenotype values</li><li><code>metrics</code>: dictionary of genomic prediction accuracy metrics, inluding Pearson&#39;s correlation, mean absolute error and root mean-squared error</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Fit(; n=1, l=10)
where:
- n::Int64: Number of entries
- l::Int64: Number of loci-alleles</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L313-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.Genomes" href="#GBCore.Genomes"><code>GBCore.Genomes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Genomes struct</strong></p><p>Containes unique entries and loci_alleles where allele frequencies can have missing values</p><p><strong>Fields</strong></p><ul><li><code>entries</code>: names of the <code>n</code> entries or samples</li><li><code>populations</code>: name/s of the population/s each entries or samples belong to</li><li><code>loci_alleles</code>: names of the <code>p</code> loci-alleles combinations (<code>p</code> = <code>l</code> loci x <code>a-1</code> alleles) including the chromsome or scaffold name, position, all alleles and current allele separated by tabs (&quot;\t&quot;)</li><li><code>allele_frequencies</code>: <code>n x p</code> matrix of allele frequencies between 0 and 1 which can have missing values</li><li><code>mask</code>: <code>n x p</code> matrix of boolean mask for selective analyses and slicing</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Genomes(; n::Int64 = 1, p::Int64 = 2)</code></pre><p>where:</p><ul><li><code>n::Int64=1</code>: Number of entries in the genomic dataset</li><li><code>p::Int64=2</code>: Number of locus-allele combinations in the genomic dataset</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2, p=2)
Genomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])

julia&gt; fieldnames(Genomes)
(:entries, :populations, :loci_alleles, :allele_frequencies, :mask)

julia&gt; genomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; genomes.populations = [&quot;pop_1&quot;, &quot;pop_1&quot;];

julia&gt; genomes.loci_alleles = [&quot;chr1\t12345\tA|T\tA&quot;, &quot;chr2\t678910\tC|D\tD&quot;];

julia&gt; genomes.allele_frequencies = [0.5 0.25; 0.9 missing];

julia&gt; genomes.mask = [true true; true false];

julia&gt; genomes
Genomes([&quot;entry_1&quot;, &quot;entry_2&quot;], [&quot;pop_1&quot;, &quot;pop_1&quot;], [&quot;chr1\t12345\tA|T\tA&quot;, &quot;chr2\t678910\tC|D\tD&quot;], Union{Missing, Float64}[0.5 0.25; 0.9 missing], Bool[1 1; 1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L17-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.Phenomes" href="#GBCore.Phenomes"><code>GBCore.Phenomes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Phenomes struct</strong></p><p>Constains unique entries and traits where phenotype data can have missing values</p><p><strong>Fields</strong></p><ul><li><code>entries</code>: names of the <code>n</code> entries or samples</li><li><code>populations</code>: name/s of the population/s each entries or samples belong to</li><li><code>traits</code>: names of the <code>t</code> traits</li><li><code>phenotypes</code>: <code>n x t</code> matrix of numeric (<code>R</code>) phenotype data which can have missing values</li><li><code>mask</code>: <code>n x t</code> matrix of boolean mask for selective analyses and slicing</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Phenomes(; n::Int64 = 1, t::Int64 = 2)</code></pre><p>where:</p><ul><li><code>n::Int64=1</code>: Number of entries in the phenomic dataset</li><li><code>t::Int64=2</code>: Number of traits in the phenomic dataset</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2)
Phenomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])

julia&gt; fieldnames(Phenomes)
(:entries, :populations, :traits, :phenotypes, :mask)

julia&gt; phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; phenomes.populations = [&quot;pop_A&quot;, &quot;pop_B&quot;];

julia&gt; phenomes.traits = [&quot;height&quot;, &quot;yield&quot;];

julia&gt; phenomes.phenotypes = [200.0 2.5; 150.0 missing];

julia&gt; phenomes.mask = [true true; true false];

julia&gt; phenomes
Phenomes([&quot;entry_1&quot;, &quot;entry_2&quot;], [&quot;pop_A&quot;, &quot;pop_B&quot;], [&quot;height&quot;, &quot;yield&quot;], Union{Missing, Float64}[200.0 2.5; 150.0 missing], Bool[1 1; 1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L71-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.SimulatedEffects" href="#GBCore.SimulatedEffects"><code>GBCore.SimulatedEffects</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>SimulatedEffects struct</strong></p><p>Contains the various simulated genetic, environmental and GxE effects.</p><p><strong>Fields</strong></p><ul><li><code>id::Vector{String}</code>: Vector of identifiers</li><li><code>year::Float64</code>: Year effect</li><li><code>season::Float64</code>: Season effect</li><li><code>site::Float64</code>: Site effect</li><li><code>seasons_x_year::Float64</code>: Interaction effect between seasons and years</li><li><code>harvests_x_season_x_year::Float64</code>: Interaction effect between harvests, seasons and years</li><li><code>sites_x_harvest_x_season_x_year::Float64</code>: Interaction effect between sites, harvests, seasons and years</li><li><code>field_layout::Matrix{Int64}</code>: 2D matrix representing field layout</li><li><code>replications_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Replication interaction effects</li><li><code>blocks_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Block interaction effects</li><li><code>rows_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Row interaction effects</li><li><code>cols_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Column interaction effects</li><li><code>additive_genetic::Vector{Float64}</code>: Additive genetic effects</li><li><code>dominance_genetic::Vector{Float64}</code>: Dominance genetic effects</li><li><code>epistasis_genetic::Vector{Float64}</code>: Epistasis genetic effects</li><li><code>additive_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Additive allele interaction effects</li><li><code>dominance_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Dominance allele interaction effects</li><li><code>epistasis_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Epistasis allele interaction effects</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SimulatedEffects()</code></pre><p>Creates a new SimulatedEffects instance with default values:</p><ul><li>Empty strings for IDs (vector of size 6)</li><li>0.0 for all float values</li><li>4x4 zero matrix for field_layout</li><li>Single-element zero vectors for all vector fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L235-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.TEBV" href="#GBCore.TEBV"><code>GBCore.TEBV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Trial-estimated breeding values (TEBV) struct</strong></p><p>Contains trial-estimated breeding values as generated by <code>analyse(trials::Trials, ...)</code>.</p><p><strong>Fields</strong></p><ul><li><code>traits</code>: names of the traits <code>t</code> traits</li><li><code>formulae</code>: best-fitting formula for each trait</li><li><code>models</code>: best-fitting linear mixed model for each trait</li><li><code>df_BLUEs</code>: vector of data frames of best linear unbiased estimators or fixed effects table of each best fitting model</li><li><code>df_BLUPs</code>: vector of data frames of best linear unbiased predictors or random effects table of each best fitting model</li><li><code>phenomes</code>: vector of Phenomes structs each containing the breeding values</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1, t=1)]);

julia&gt; tebv.traits
1-element Vector{String}:
 &quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L193-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.Trials" href="#GBCore.Trials"><code>GBCore.Trials</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Trials struct</strong></p><p>Contains phenotype data across years, seasons, harvest, sites, populations, replications, blocks, rows, and columns</p><p><strong>Fields</strong></p><ul><li><code>phenotypes</code>: <code>n x t</code> matrix of numeric phenotype data which can have missing values</li><li><code>traits</code>: names of the traits <code>t</code> traits</li><li><code>years</code>: names of the years corresponding to each row in the phenotype matrix</li><li><code>seasons</code>: names of the seasons corresponding to each row in the phenotype matrix</li><li><code>harvests</code>: names of the harvests corresponding to each row in the phenotype matrix</li><li><code>sites</code>: names of the sites corresponding to each row in the phenotype matrix</li><li><code>replications</code>: names of the replications corresponding to each row in the phenotype matrix</li><li><code>blocks</code>: names of the blocks corresponding to each row in the phenotype matrix</li><li><code>rows</code>: names of the rows corresponding to each row in the phenotype matrix</li><li><code>cols</code>: names of the cols corresponding to each row in the phenotype matrix</li><li><code>entries</code>: names of the entries corresponding to each row in the phenotype matrix</li><li><code>populations</code>: names of the populations corresponding to each row in the phenotype matrix</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Trials(; n::Int64 = 2, p::Int64 = 2)</code></pre><p>where:</p><ul><li><code>n::Int64=1</code>: Number of entries in the trials</li><li><code>t::Int64=2</code>: Number of traits in the trials</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2)
Trials(Union{Missing, Float64}[missing missing], [&quot;&quot;, &quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;])

julia&gt; fieldnames(Trials)
(:phenotypes, :traits, :years, :seasons, :harvests, :sites, :replications, :blocks, :rows, :cols, :entries, :populations)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/all_structs.jl#L125-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{CV, CV}" href="#Base.:==-Tuple{CV, CV}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.:(==)(x::CV, y::CV)::Bool</code></pre><p>Compare two CV (Cross-Validation) structs for equality.</p><p>This method overloads the equality operator (<code>==</code>) for CV structs by comparing their hash values. Two CV structs are considered equal if they have identical values for all fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::CV</code>: First CV struct to compare</li><li><code>y::CV</code>: Second CV struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the CV structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; cv_2 = clone(cv_1);

julia&gt; cv_3 = clone(cv_1); cv_3.replication = &quot;other_replication&quot;;

julia&gt; cv_1 == cv_2
true

julia&gt; cv_1 == cv_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/cv.jl#L88-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{Fit, Fit}" href="#Base.:==-Tuple{Fit, Fit}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.:(==)(x::Fit, y::Fit)::Bool</code></pre><p>Compare two <code>Fit</code> structs for equality based on their hash values.</p><p>This method defines equality comparison for <code>Fit</code> structs by comparing their hash values. Two <code>Fit</code> structs are considered equal if they have identical hash values, which means they have the same values for all their fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::Fit</code>: First Fit struct to compare</li><li><code>y::Fit</code>: Second Fit struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the Fit structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit_1 = Fit(n=1, l=4);

julia&gt; fit_2 = Fit(n=1, l=4);

julia&gt; fit_3 = Fit(n=1, l=2);

julia&gt; fit_1 == fit_2
true

julia&gt; fit_1 == fit_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/fit.jl#L85-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{Genomes, Genomes}" href="#Base.:==-Tuple{Genomes, Genomes}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(x::Genomes, y::Genomes)::Bool</code></pre><p>Compare two <code>Genomes</code> structs for equality by comparing their hash values.</p><p>This method implements equality comparison for <code>Genomes</code> structs by utilizing their hash values, ensuring that two genomes are considered equal if and only if they have identical structural properties and content.</p><p><strong>Arguments</strong></p><ul><li><code>x::Genomes</code>: First Genomes struct to compare</li><li><code>y::Genomes</code>: Second Genomes struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the genomes are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes_1 = genomes = Genomes(n=2,p=4);

julia&gt; genomes_2 = genomes = Genomes(n=2,p=4);

julia&gt; genomes_3 = genomes = Genomes(n=1,p=2);

julia&gt; genomes_1 == genomes_2
true

julia&gt; genomes_1 == genomes_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L79-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{Phenomes, Phenomes}" href="#Base.:==-Tuple{Phenomes, Phenomes}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(x::Phenomes, y::Phenomes)::Bool</code></pre><p>Compare two <code>Phenomes</code> structs for equality using their hash values.</p><p>This method implements equality comparison for <code>Phenomes</code> objects by comparing their hash values, ensuring that two phenomes with identical structure and content are considered equal.</p><p><strong>Arguments</strong></p><ul><li><code>x::Phenomes</code>: First phenomes object to compare</li><li><code>y::Phenomes</code>: Second phenomes object to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the phenomes are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes_1 = phenomes = Phenomes(n=2, t=4);

julia&gt; phenomes_2 = phenomes = Phenomes(n=2, t=4);

julia&gt; phenomes_3 = phenomes = Phenomes(n=1, t=2);

julia&gt; phenomes_1 == phenomes_2
true

julia&gt; phenomes_1 == phenomes_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L72-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{SimulatedEffects, SimulatedEffects}" href="#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.:(==)(x::SimulatedEffects, y::SimulatedEffects)::Bool</code></pre><p>Equality of SimulatedEffects structs using the hash function defined for SimulatedEffects structs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects_1 = SimulatedEffects();

julia&gt; effects_2 = SimulatedEffects();

julia&gt; effects_3 = SimulatedEffects(); effects_3.id[1] = &quot;SOMETHING_ELSE&quot;;

julia&gt; effects_1 == effects_2
true

julia&gt; effects_1 == effects_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_effects.jl#L76-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{TEBV, TEBV}" href="#Base.:==-Tuple{TEBV, TEBV}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(x::TEBV, y::TEBV)::Bool</code></pre><p>Compare two TEBV (Trial-Estimated Breeding Values) objects for equality.</p><p>This method implements equality comparison for TEBV structs by comparing their hash values. Two TEBV objects are considered equal if they have identical values for all their fields: traits, formulae, models, df<em>BLUEs, df</em>BLUPs, and phenomes.</p><p><strong>Arguments</strong></p><ul><li><code>x::TEBV</code>: First TEBV object to compare</li><li><code>y::TEBV</code>: Second TEBV object to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the TEBV objects are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv_1 = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; tebv_2 = clone(tebv_1);

julia&gt; tebv_3 = TEBV(traits=[&quot;SOMETHING_ELSE&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; tebv_1 == tebv_2
true

julia&gt; tebv_1 == tebv_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L83-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{Trials, Trials}" href="#Base.:==-Tuple{Trials, Trials}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(x::Trials, y::Trials)::Bool</code></pre><p>Compare two <code>Trials</code> structs for equality by comparing their hash values.</p><p>Two <code>Trials</code> structs are considered equal if they have identical hash values, which implies they have the same configuration parameters (number of trials <code>n</code> and time steps <code>t</code>).</p><p><strong>Arguments</strong></p><ul><li><code>x::Trials</code>: First Trials struct to compare</li><li><code>y::Trials</code>: Second Trials struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the Trials structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials_1 = trials = Trials(n=2, t=4);

julia&gt; trials_2 = trials = Trials(n=2, t=4);

julia&gt; trials_3 = trials = Trials(n=1, t=2);

julia&gt; trials_1 == trials_2
true

julia&gt; trials_1 == trials_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L65-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.filter-Tuple{Genomes, Float64}" href="#Base.filter-Tuple{Genomes, Float64}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter(
    genomes::Genomes,
    maf::Float64;
    max_entry_sparsity::Float64 = 0.0,
    max_locus_sparsity::Float64 = 0.0,
    chr_pos_allele_ids::Union{Nothing,Vector{String}} = nothing,
    verbose::Bool = false
)::Genomes</code></pre><p>Filter a Genomes struct based on multiple criteria.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Input genomic data structure</li><li><code>maf::Float64</code>: Minimum allele frequency threshold (0.0 to 1.0)</li><li><code>max_entry_sparsity::Float64</code>: Maximum allowed proportion of missing values per entry (default: 0.0)</li><li><code>max_locus_sparsity::Float64</code>: Maximum allowed proportion of missing values per locus (default: 0.0)</li><li><code>chr_pos_allele_ids::Union{Nothing,Vector{String}}</code>: Optional vector of specific locus-allele combinations to retain,    formatted as tab-separated strings &quot;chromosome\tposition\tallele&quot;</li><li><code>verbose::Bool</code>: Whether to display progress bars during filtering (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: Filtered genomic data structure</li></ul><p><strong>Description</strong></p><p>Filters genomic data based on four criteria:</p><ol><li>Minimum allele frequency (MAF)</li><li>Maximum entry sparsity (proportion of missing values per entry)</li><li>Maximum locus sparsity (proportion of missing values per locus)</li><li>Specific locus-allele combinations (optional)</li></ol><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If Genomes struct is corrupted, if MAF is outside [0,1], or if chr<em>pos</em>allele_ids format is invalid</li><li><code>ErrorException</code>: If filtering results in empty dataset</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; filtered_genomes_1 = filter(genomes, 0.1);

julia&gt; filtered_genomes_2 = filter(genomes, 0.1, chr_pos_allele_ids=genomes.loci_alleles[1:1000]);

julia&gt; size(genomes.allele_frequencies)
(100, 3000)

julia&gt; size(filtered_genomes_1.allele_frequencies)
(100, 1236)

julia&gt; size(filtered_genomes_2.allele_frequencies)
(100, 388)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L895-L947">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.filter-Tuple{Genomes}" href="#Base.filter-Tuple{Genomes}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter(genomes::Genomes; verbose::Bool = false)::Genomes</code></pre><p>Filter a Genomes struct by removing entries and loci with missing data based on the mask matrix.</p><p><strong>Description</strong></p><p>This function filters a Genomes struct by:</p><ol><li>Removing rows (entries) where any column has a false value in the mask matrix</li><li>Removing columns (loci) where any row has a false value in the mask matrix</li></ol><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Input Genomes struct containing genetic data and a mask matrix</li><li><code>verbose::Bool</code>: Optional flag to control verbose output (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new filtered Genomes struct with complete data (no missing values)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(verbose=false); genomes.mask[1:10, 42:100] .= false;
    
julia&gt; filtered_genomes = filter(genomes);

julia&gt; size(filtered_genomes.allele_frequencies)
(90, 9941)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L858-L884">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.filter-Tuple{Phenomes}" href="#Base.filter-Tuple{Phenomes}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter(phenomes::Phenomes)::Phenomes</code></pre><p>Filter a Phenomes struct by removing rows (entries) and columns (traits) as indicated by the mask matrix.  An entry or trait is removed if it contains at least one false value in the mask.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: The Phenomes struct to be filtered, containing entries, populations, traits, phenotypes, and a boolean mask matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes struct with filtered entries and traits, where the mask matrix is all true.</li></ul><p><strong>Details</strong></p><p>The function uses the mean of rows and columns in the mask matrix to identify which entries and traits should be kept. Only entries and traits with a mean of 1.0 (all true values) are retained in the filtered result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; phenomes.mask .= true; phenomes.mask[6:10, 1] .= false;
    
julia&gt; filtered_phenomes = filter(phenomes);

julia&gt; size(filtered_phenomes.phenotypes)
(5, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L626-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{CV, UInt64}" href="#Base.hash-Tuple{CV, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::CV, h::UInt)::UInt</code></pre><p>Compute a hash value for a CV (Cross-Validation) struct.</p><p>This method defines how CV structs should be hashed, which is useful for using CV objects in hash-based collections like Sets or as Dict keys.</p><p><strong>Arguments</strong></p><ul><li><code>x::CV</code>: The CV struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with the new hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the CV struct</li></ul><p><strong>Implementation Details</strong></p><p>The hash is computed by combining the following fields:</p><ul><li>replication</li><li>fold</li><li>fit</li><li>validation_populations</li><li>validation_entries</li><li>validation<em>y</em>true</li><li>validation<em>y</em>pred</li><li>metrics</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; typeof(hash(cv))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/cv.jl#L43-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{Fit, UInt64}" href="#Base.hash-Tuple{Fit, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::Fit, h::UInt)::UInt</code></pre><p>Calculate a hash value for a <code>Fit</code> struct.</p><p>This method implements hashing for the <code>Fit</code> type by combining the hashes of its core components in a specific order. The hash is computed using the following fields:</p><ul><li>model</li><li>b_hat (estimated effects)</li><li>trait</li><li>entries</li><li>populations</li><li>metrics</li><li>y_true (observed values)</li><li>y_pred (predicted values)</li></ul><p><strong>Arguments</strong></p><ul><li><code>x::Fit</code>: The Fit struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: The computed hash value</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; typeof(hash(fit))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/fit.jl#L45-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{Genomes, UInt64}" href="#Base.hash-Tuple{Genomes, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::Genomes, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>Genomes</code> struct.</p><p>This hash function considers three key components of the <code>Genomes</code> struct:</p><ul><li>entries</li><li>populations</li><li>loci_alleles</li></ul><p>For performance reasons, <code>allele_frequencies</code> and <code>mask</code> fields are deliberately excluded  from the hash computation.</p><p><strong>Arguments</strong></p><ul><li><code>x::Genomes</code>: The Genomes struct to hash</li><li><code>h::UInt</code>: The hash seed value</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the Genomes struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2, p=2);

julia&gt; typeof(hash(genomes))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L39-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{Phenomes, UInt64}" href="#Base.hash-Tuple{Phenomes, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::Phenomes, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>Phenomes</code> struct by recursively hashing its internal fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::Phenomes</code>: The Phenomes struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the entire Phenomes struct</li></ul><p><strong>Note</strong></p><p>This function is used for dictionary operations and computing hash-based data structures. The hash is computed by combining hashes of all internal fields: entries, populations, traits, phenotypes, and mask.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2);

julia&gt; typeof(hash(phenomes))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L38-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{SimulatedEffects, UInt64}" href="#Base.hash-Tuple{SimulatedEffects, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::SimulatedEffects, h::UInt)::UInt</code></pre><p>Hash a SimulatedEffects struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects = SimulatedEffects();

julia&gt; typeof(hash(effects))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_effects.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{TEBV, UInt64}" href="#Base.hash-Tuple{TEBV, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::TEBV, h::UInt)::UInt</code></pre><p>Calculate a hash value for a TEBV (Trial-Estimated Breeding Value) struct.</p><p>This method implements hashing for TEBV objects by combining the hash values of selected fields:</p><ul><li>traits: Vector of trait names</li><li>formulae: Vector of formula strings</li><li>phenomes: Vector of Phenomes objects</li></ul><p>Note: For performance reasons, the following fields are deliberately excluded from the hash calculation:</p><ul><li>models</li><li>df_BLUEs</li><li>df_BLUPs</li></ul><p><strong>Arguments</strong></p><ul><li><code>x::TEBV</code>: The TEBV struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with the object&#39;s hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A unique hash value for the TEBV object</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; typeof(hash(tebv))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L41-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{Trials, UInt64}" href="#Base.hash-Tuple{Trials, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::Trials, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>Trials</code> struct by recursively hashing all of its fields.</p><p>This method implements hash functionality for the <code>Trials</code> type, allowing <code>Trials</code>  objects to be used as dictionary keys or in hash-based collections.</p><p><strong>Arguments</strong></p><ul><li><code>x::Trials</code>: The Trials struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with the object&#39;s hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the entire Trials struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=2, t=2);

julia&gt; typeof(hash(trials))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L33-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge-Tuple{Genomes, Genomes}" href="#Base.merge-Tuple{Genomes, Genomes}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge(
    genomes::Genomes,
    other::Genomes;
    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),
    verbose::Bool = true
)::Genomes</code></pre><p>Merge two Genomes structs by combining their entries and loci_alleles while resolving conflicts in allele frequencies.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: First Genomes struct to merge</li><li><code>other::Genomes</code>: Second Genomes struct to merge</li><li><code>conflict_resolution::Tuple{Float64,Float64}</code>: Weights for resolving conflicts between allele frequencies (must sum to 1.0)</li><li><code>verbose::Bool</code>: If true, displays a progress bar during merging</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes struct containing the merged data</li></ul><p><strong>Details</strong></p><p>The function performs the following operations:</p><ol><li>Combines unique entries and loci_alleles from both input structs</li><li>Resolves population conflicts by concatenating conflicting values</li><li>For overlapping entries and loci:<ul><li>If allele frequencies match, uses the existing value</li><li>If frequencies differ, applies weighted average using conflict_resolution</li><li>For missing values, uses available non-missing value</li><li>Resolves mask conflicts using weighted average</li></ul></li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n = 100; l = 5_000; n_alleles = 2;

julia&gt; all = simulategenomes(n=n, l=l, n_alleles=n_alleles, verbose=false);

julia&gt; genomes = slice(all, idx_entries=collect(1:Int(floor(n*0.75))), idx_loci_alleles=collect(1:Int(floor(l*(n_alleles-1)*0.75))));

julia&gt; other = slice(all, idx_entries=collect(Int(floor(n*0.50)):n), idx_loci_alleles=collect(Int(floor(l*(n_alleles-1)*0.50)):l*(n_alleles-1)));

julia&gt; merged_genomes = merge(genomes, other, conflict_resolution=(0.75, 0.25), verbose=false);

julia&gt; size(merged_genomes.allele_frequencies)
(100, 5000)

julia&gt; sum(ismissing.(merged_genomes.allele_frequencies))
123725</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L1116-L1163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge-Tuple{Genomes, Phenomes}" href="#Base.merge-Tuple{Genomes, Phenomes}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge(genomes::Genomes, phenomes::Phenomes; keep_all::Bool=true)::Tuple{Genomes,Phenomes}</code></pre><p>Merge <code>Genomes</code> and <code>Phenomes</code> structs based on their entries, combining genomic and phenotypic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A struct containing genomic data including entries, populations, and allele frequencies</li><li><code>phenomes::Phenomes</code>: A struct containing phenotypic data including entries, populations, and phenotypes</li><li><code>keep_all::Bool=true</code>: If true, performs a union of entries; if false, performs an intersection</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Genomes,Phenomes}</code>: A tuple containing:<ul><li>A new <code>Genomes</code> struct with merged entries and corresponding genomic data</li><li>A new <code>Phenomes</code> struct with merged entries and corresponding phenotypic data</li></ul></li></ul><p><strong>Details</strong></p><ul><li>Maintains dimensional consistency between input and output structs</li><li>Handles population conflicts by creating a combined population name</li><li>Preserves allele frequencies and phenotypic data for matched entries</li><li>When <code>keep_all=true</code>, includes all entries from both structs</li><li>When <code>keep_all=false</code>, includes only entries present in both structs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=10, verbose=false);

julia&gt; trials, effects = simulatetrials(genomes=slice(genomes, idx_entries=collect(1:5), idx_loci_alleles=collect(1:length(genomes.loci_alleles))), f_add_dom_epi=[0.90 0.05 0.05;], n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=2, verbose=false);

julia&gt; phenomes = Phenomes(n=5, t=1);

julia&gt; phenomes.entries = trials.entries[1:5];

julia&gt; phenomes.populations = trials.populations[1:5];

julia&gt; phenomes.traits = trials.traits;

julia&gt; phenomes.phenotypes = trials.phenotypes[1:5, :];

julia&gt; phenomes.mask .= true;

julia&gt; genomes_merged_1, phenomes_merged_1 = merge(genomes, phenomes, keep_all=true);

julia&gt; size(genomes_merged_1.allele_frequencies), size(phenomes_merged_1.phenotypes)
((10, 10000), (10, 1))

julia&gt; genomes_merged_2, phenomes_merged_2 = merge(genomes, phenomes, keep_all=false);

julia&gt; size(genomes_merged_2.allele_frequencies), size(phenomes_merged_2.phenotypes)
((5, 10000), (5, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L1288-L1338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge-Tuple{Phenomes, Phenomes}" href="#Base.merge-Tuple{Phenomes, Phenomes}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge(
    phenomes::Phenomes,
    other::Phenomes;
    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),
    verbose::Bool = true
)::Phenomes</code></pre><p>Merge two <code>Phenomes</code> structs into a single combined struct, handling overlapping entries and traits.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: The first Phenomes struct to merge</li><li><code>other::Phenomes</code>: The second Phenomes struct to merge</li><li><code>conflict_resolution::Tuple{Float64,Float64}</code>: Weights for resolving conflicts between overlapping values (must sum to 1.0)</li><li><code>verbose::Bool</code>: Whether to display a progress bar during merging</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new merged Phenomes struct containing all entries and traits from both input structs</li></ul><p><strong>Details</strong></p><p>The merge operation combines:</p><ul><li>All unique entries from both structs</li><li>All unique traits from both structs</li><li>Phenotype values and masks, using weighted averaging for conflicts</li><li>Population information, marking conflicts with a &quot;CONFLICT&quot; prefix</li></ul><p>For overlapping entries and traits:</p><ul><li>Identical values are preserved as-is</li><li>Different values are combined using the weights specified in <code>conflict_resolution</code></li><li>Missing values are handled by using the available non-missing value</li><li>Population conflicts are marked in the format &quot;CONFLICT (pop1, pop2)&quot;</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either Phenomes struct is corrupted (invalid dimensions)</li><li><code>ArgumentError</code>: If conflict_resolution weights don&#39;t sum to 1.0 or aren&#39;t a 2-tuple</li><li><code>ErrorException</code>: If the merging operation produces an invalid result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; all = Phenomes(n=10, t=3); all.entries = string.(&quot;entry_&quot;, 1:10); all.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; all.phenotypes = rand(10,3);

julia&gt; phenomes = slice(all, idx_entries=collect(1:7), idx_traits=[1,2]);

julia&gt; other = slice(all, idx_entries=collect(5:10), idx_traits=[2,3]);

julia&gt; merged_phenomes = merge(phenomes, other, conflict_resolution=(0.75, 0.25), verbose=false);

julia&gt; size(merged_phenomes.phenotypes)
(10, 3)

julia&gt; sum(ismissing.(merged_phenomes.phenotypes))
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L664-L717">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Tuple{SimulatedEffects}" href="#Base.sum-Tuple{SimulatedEffects}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum(effects::SimulatedEffects)::Tuple{Int64, Int64, Int64}</code></pre><p>Sum up the simulated effects to generate the simulated phenotype values</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects = SimulatedEffects();

julia&gt; sum(effects)
1-element Vector{Float64}:
 0.0

julia&gt; effects.additive_genetic[1] = pi;

julia&gt; sum(effects)
1-element Vector{Float64}:
 3.141592653589793</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_effects.jl#L137-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.addcompositetrait-Tuple{Phenomes}" href="#GBCore.addcompositetrait-Tuple{Phenomes}"><code>GBCore.addcompositetrait</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addcompositetrait(phenomes::Phenomes; composite_trait_name::String, formula_string::String)::Phenomes</code></pre><p>Create a new composite trait by combining existing traits using mathematical operations.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing the original trait data</li><li><code>composite_trait_name::String</code>: Name for the new composite trait</li><li><code>formula_string::String</code>: Mathematical formula describing how to combine existing traits.  Supports traits as variables and the following operations:<ul><li>Basic arithmetic: +, -, *, /, ^, %</li><li>Functions: abs(), sqrt(), log(), log2(), log10()</li><li>Parentheses for operation precedence</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes struct with the composite trait added as the last column</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3);

julia&gt; phenomes_new = addcompositetrait(phenomes, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;A&quot;);

julia&gt; phenomes_new.phenotypes[:, end] == phenomes.phenotypes[:, 1]
true

julia&gt; phenomes_new = addcompositetrait(phenomes, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;(A^B) + (C/A) - sqrt(abs(B-A)) + log(1.00 + C)&quot;);

julia&gt; phenomes_new.phenotypes[:, end] == (phenomes.phenotypes[:,1].^phenomes.phenotypes[:,2]) .+ (phenomes.phenotypes[:,3]./phenomes.phenotypes[:,1]) .- sqrt.(abs.(phenomes.phenotypes[:,2].-phenomes.phenotypes[:,1])) .+ log.(1.00 .+ phenomes.phenotypes[:,3])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L906-L937">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.addcompositetrait-Tuple{Trials}" href="#GBCore.addcompositetrait-Tuple{Trials}"><code>GBCore.addcompositetrait</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addcompositetrait(trials::Trials; composite_trait_name::String, formula_string::String)::Trials</code></pre><p>Create a new composite trait by combining existing traits using a mathematical formula.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing phenotypic data</li><li><code>composite_trait_name::String</code>: Name for the new composite trait</li><li><code>formula_string::String</code>: Mathematical formula defining how to combine existing traits</li></ul><p><strong>Formula Syntax</strong></p><p>The formula can include:</p><ul><li>Trait names (e.g., &quot;trait<em>1&quot;, &quot;trait</em>2&quot;)</li><li>Mathematical operators: +, -, *, /, ^, %</li><li>Functions: abs(), sqrt(), log(), log2(), log10()</li><li>Parentheses for grouping operations</li></ul><p><strong>Returns</strong></p><ul><li><code>Trials</code>: A new Trials struct with the added composite trait</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; trials_new = addcompositetrait(trials, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;trait_1&quot;);

julia&gt; trials_new.phenotypes[:, end] == trials.phenotypes[:, 1]
true

julia&gt; trials_new = addcompositetrait(trials, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;(trait_1^(trait_2/100)) + (trait_3/trait_1) - sqrt(abs(trait_2-trait_1)) + log(1.00 + trait_3)&quot;);

julia&gt; trials_new.phenotypes[:, end] == (trials.phenotypes[:,1].^(trials.phenotypes[:,2]/100)) .+ (trials.phenotypes[:,3]./trials.phenotypes[:,1]) .- sqrt.(abs.(trials.phenotypes[:,2].-trials.phenotypes[:,1])) .+ log.(1.00 .+ trials.phenotypes[:,3])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L396-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.analyse" href="#GBCore.analyse"><code>GBCore.analyse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyse(
    trials::Trials,
    formula_string::String = &quot;&quot;;
    traits::Union{Nothing,Vector{String}} = nothing,
    max_levels::Int64 = 100,
    max_time_per_model::Int64 = 60,
    covariates_continuous::Union{Nothing,Vector{String}} = nothing,
    verbose::Bool = true
)::TEBV</code></pre><p>Analyze trial data using linear mixed models to estimate Best Linear Unbiased Estimates (BLUEs)  and Best Linear Unbiased Predictions (BLUPs).</p><p><strong>Arguments</strong></p><ul><li><code>trials</code>: A Trials struct containing the experimental data</li><li><code>formula_string</code>: Optional model formula string. If empty, automatic model selection is performed</li><li><code>traits</code>: Optional vector of trait names to analyze. If nothing, all traits are analyzed</li><li><code>max_levels</code>: Maximum number of levels for non-entry random effects (default: 100)</li><li><code>max_time_per_model</code>: Maximum fitting time in seconds per model (default: 60)</li><li><code>covariates_continuous</code>: Optional vector of continuous covariates to include in models</li><li><code>verbose</code>: Whether to display analysis progress (default: true)</li></ul><p><strong>Returns</strong></p><p>A <code>TEBV</code> struct containing:</p><ul><li><code>traits</code>: Vector of analyzed trait names</li><li><code>formulae</code>: Vector of best-fitting model formulae</li><li><code>models</code>: Vector of fitted LinearMixedModel objects</li><li><code>df_BLUEs</code>: Vector of DataFrames containing BLUEs</li><li><code>df_BLUPs</code>: Vector of DataFrames containing BLUPs</li><li><code>phenomes</code>: Vector of Phenomes objects with predicted values</li></ul><p><strong>Details</strong></p><p>The function implements a mixed model fitting strategy with the following principles:</p><ul><li>Avoids over-parameterization</li><li>Uses unstructured variance-covariance matrix for random effects</li><li>Prefers REML over ML estimation</li><li>Compares BLUEs vs BLUPs of entries</li><li>Handles both parallel and iterative model fitting based on model complexity</li></ul><p><strong>Notes</strong></p><ul><li>Models are fitted using REML</li><li>Simple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues</li><li>Returns empty results if no models can be successfully fitted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);

julia&gt; tebv_1 = analyse(trials, &quot;trait_1 ~ 1 + (1|entries)&quot;, max_levels=50, verbose=false);

julia&gt; tebv_1.traits
3-element Vector{String}:
 &quot;trait_1&quot;
 &quot;trait_2&quot;
 &quot;trait_3&quot;

julia&gt; tebv_2 = analyse(trials, max_levels=50, verbose=false);

julia&gt; mean(tebv_2.phenomes[1].phenotypes) &lt; mean(tebv_2.phenomes[2].phenotypes)
true

julia&gt; trials = addcompositetrait(trials, composite_trait_name = &quot;covariate&quot;, formula_string = &quot;(trait_1 + trait_2) / (trait_3 + 0.0001)&quot;);

julia&gt; tebv_3 = Suppressor.@suppress analyse(trials, &quot;y ~ 1 + covariate + entries + (1|blocks)&quot;, max_levels=50, verbose=false);

julia&gt; mean(tebv_3.phenomes[1].phenotypes) &lt; mean(tebv_3.phenomes[2].phenotypes)
true

julia&gt; tebv_4 = Suppressor.@suppress analyse(trials, max_levels=50, covariates_continuous=[&quot;covariate&quot;], verbose=false);

julia&gt; mean(tebv_4.phenomes[1].phenotypes) &lt; mean(tebv_4.phenomes[2].phenotypes)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L831-L905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.analyse-Tuple{DataFrames.DataFrame}" href="#GBCore.analyse-Tuple{DataFrames.DataFrame}"><code>GBCore.analyse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyse(
    df::DataFrame; 
    formulae::Vector{String},
    idx_parallel_models::Vector{Int64},
    idx_iterative_models::Vector{Int64},
    max_time_per_model::Int64 = 60,
    verbose::Bool=false
)::Tuple{String, Any, DataFrame, DataFrame, Phenomes}</code></pre><p>Fit univariate linear mixed models to extract entry effects from the best-fitting model.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Input data frame containing trial data with columns for entries, traits, and other experimental factors</li><li><code>formulae::Vector{String}</code>: Vector of model formulae strings to be tested</li><li><code>idx_parallel_models::Vector{Int64}</code>: Indices of simpler models to be fitted in parallel</li><li><code>idx_iterative_models::Vector{Int64}</code>: Indices of complex models to be fitted iteratively</li><li><code>max_time_per_model::Int64</code>: Maximum time in seconds allowed for fitting each model (default: 60)</li><li><code>verbose::Bool</code>: Whether to display progress information (default: false)</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li>String: Formula of the best-fitting model</li><li>Any: The fitted model object</li><li>DataFrame: BLUEs (Best Linear Unbiased Estimates) results</li><li>DataFrame: BLUPs (Best Linear Unbiased Predictions) results</li><li>Phenomes: Struct containing consolidated phenotypic predictions</li></ol><p><strong>Details</strong></p><p>The function implements a mixed model fitting strategy with the following principles:</p><ul><li>Avoids over-parameterization</li><li>Uses unstructured variance-covariance matrix for random effects</li><li>Prefers REML over ML estimation</li><li>Compares BLUEs vs BLUPs of entries</li><li>Handles both parallel and iterative model fitting based on model complexity</li></ul><p><strong>Notes</strong></p><ul><li>All formulae must model the same trait</li><li>Models are fitted using REML</li><li>Simple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues</li><li>Returns empty results if no models can be successfully fitted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; df = tabularise(trials);

julia&gt; formulae, n_levels = trialsmodelsfomulae!(df; trait = &quot;trait_1&quot;, max_levels = 10);

julia&gt; idx_parallel_models::Vector{Int64} = findall(n_levels .&lt;= (15));

julia&gt; idx_iterative_models::Vector{Int64} = findall((n_levels .&lt;= (15)) .!= true);

julia&gt; formula_string, model, df_BLUEs, df_BLUPs, phenomes = analyse(df, formulae=formulae, idx_parallel_models=idx_parallel_models, idx_iterative_models=idx_iterative_models);

julia&gt; length(phenomes.entries) == length(unique(df.entries))
true

julia&gt; df_2 = df[(df.years .== df.years[1]) .&amp;&amp; (df.harvests .== df.harvests[1]) .&amp;&amp; (df.seasons .== df.seasons[1]) .&amp;&amp; (df.sites .== df.sites[1]) .&amp;&amp; (df.replications .== df.replications[1]), :];

julia&gt; formula_string_2, model_2, df_BLUEs_2, df_BLUPs_2, phenomes_2 = analyse(df_2, formulae=[&quot;trait_1 ~ 1 + 1|entries&quot;]);

julia&gt; cor(phenomes_2.phenotypes[sortperm(phenomes_2.entries),1], df_2.trait_1[sortperm(df_2.entries)]) &gt; 0.99
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L530-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{CV}" href="#GBCore.checkdims-Tuple{CV}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(cv::CV)::Bool</code></pre><p>Check dimension compatibility of the fields of the CV struct.</p><p>The function verifies that:</p><ul><li>The fit object dimensions are valid</li><li>The number of validation populations matches the number of validation entries</li><li>The number of validation true values matches the number of validation predictions</li><li>The number of metrics matches the number of metrics in the fit object</li></ul><p>Returns:</p><ul><li><code>true</code> if all dimensions are compatible</li><li><code>false</code> if any dimension mismatch is found</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; checkdims(cv)
true

julia&gt; cv.validation_y_true = [0.0, 0.0];

julia&gt; checkdims(cv)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/cv.jl#L125-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{Fit}" href="#GBCore.checkdims-Tuple{Fit}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(fit::Fit)::Bool</code></pre><p>Check dimension compatibility of the internal fields of a <code>Fit</code> struct.</p><p>This function verifies that all vector fields in the <code>Fit</code> struct have compatible dimensions:</p><ul><li>Length of <code>entries</code>, <code>populations</code>, <code>y_true</code>, and <code>y_pred</code> must be equal (denoted as <code>n</code>)</li><li>Length of <code>b_hat</code> and <code>b_hat_labels</code> must be equal (denoted as <code>l</code>)</li></ul><p>Returns <code>true</code> if all dimensions are compatible, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: The Fit struct to check dimensions for</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=4);

julia&gt; checkdims(fit)
true

julia&gt; fit.b_hat_labels = [&quot;chr1\t1\tA|T\tA&quot;];

julia&gt; checkdims(fit)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/fit.jl#L121-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{Genomes}" href="#GBCore.checkdims-Tuple{Genomes}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(genomes::Genomes)::Bool</code></pre><p>Check dimension compatibility of the fields in a <code>Genomes</code> struct.</p><p>Returns <code>true</code> if all dimensions are compatible, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing genomic data</li></ul><p><strong>Details</strong></p><p>Verifies that:</p><ul><li>Number of entries matches number of populations (n)</li><li>Entry names are unique</li><li>Number of loci alleles matches width of frequency matrix (p) </li><li>Locus-allele combinations are unique</li><li>Entries are unique</li><li>Dimensions of frequency matrix (n×p) match mask matrix dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2,p=4);

julia&gt; checkdims(genomes)
false

julia&gt; genomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; genomes.loci_alleles = [&quot;chr1\t1\tA|T\tA&quot;, &quot;chr1\t2\tC|G\tG&quot;, &quot;chr2\t3\tA|T\tA&quot;, &quot;chr2\t4\tG|T\tG&quot;];

julia&gt; checkdims(genomes)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L115-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{Phenomes}" href="#GBCore.checkdims-Tuple{Phenomes}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(y::Phenomes)::Bool</code></pre><p>Verify dimensional compatibility between all fields of a Phenomes struct.</p><p>Checks if:</p><ul><li>Number of entries matches the number of rows in phenotypes matrix</li><li>All entry names are unique</li><li>Number of populations matches number of entries</li><li>Number of traits matches number of columns in phenotypes matrix</li><li>All trait names are unique</li><li>Dimensions of mask matrix match phenotypes matrix</li></ul><p><strong>Arguments</strong></p><ul><li><code>y::Phenomes</code>: A Phenomes struct containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if all dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = Phenomes(n=2, t=2);

julia&gt; checkdims(y)
false

julia&gt; y.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; y.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; checkdims(y)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L107-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{SimulatedEffects}" href="#GBCore.checkdims-Tuple{SimulatedEffects}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(effects::SimulatedEffects)::Bool</code></pre><p>Check dimension compatibility of the fields of the SimulatedEffects struct</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects = SimulatedEffects();

julia&gt; checkdims(effects)
true

julia&gt; effects.id = [&quot;beaking_change&quot;];

julia&gt; checkdims(effects)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_effects.jl#L101-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{TEBV}" href="#GBCore.checkdims-Tuple{TEBV}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(y::TEBV)::Bool</code></pre><p>Check if all fields in the TEBV struct have compatible dimensions. The function verifies that the length of all arrays in the TEBV struct match the number of traits.</p><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A TEBV (Trial-estimated Breeding Values) struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: Returns <code>true</code> if all fields have matching dimensions (equal to the number of traits), <code>false</code> otherwise.</li></ul><p><strong>Details</strong></p><p>The function checks if the following fields have the same length as <code>traits</code>:</p><ul><li>formulae</li><li>unique models</li><li>unique BLUEs DataFrames</li><li>unique BLUPs DataFrames</li><li>unique phenomes</li></ul><p><strong>Examples</strong></p><p>julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df<em>BLUEs=[DataFrame(x=1)], df</em>BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);</p><p>julia&gt; checkdims(tebv) true ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L119-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{Trials}" href="#GBCore.checkdims-Tuple{Trials}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(trials::Trials)::Bool</code></pre><p>Check dimension compatibility of all fields in a <code>Trials</code> struct.</p><p>This function verifies that the dimensions of all vector fields in the <code>Trials</code> struct are  consistent with the size of the phenotypes matrix. Specifically, it checks:</p><ul><li>Number of traits (<code>t</code>) matches number of columns in phenotypes and length of traits vector</li><li>Number of entries (<code>n</code>) matches number of rows in phenotypes and length of:<ul><li>years</li><li>seasons</li><li>harvests</li><li>sites</li><li>replications</li><li>blocks</li><li>rows</li><li>cols</li><li>entries</li><li>populations</li></ul></li></ul><p>Returns <code>true</code> if all dimensions are compatible, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing trial data</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2);

julia&gt; trials.entries = [&quot;entry_1&quot;]; trials.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; checkdims(trials)
true

julia&gt; trials.entries = [&quot;entering_2_entries&quot;, &quot;instead_of_just_1&quot;];

julia&gt; checkdims(trials)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L100-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{CV}" href="#GBCore.clone-Tuple{CV}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::CV)::CV</code></pre><p>Create a deep copy of a CV (cross-validation) object.</p><p>Creates a new CV object with deep copies of all fields from the input object. The clone function ensures that modifications to the cloned object do not affect  the original object.</p><p><strong>Arguments</strong></p><ul><li><code>x::CV</code>: The CV object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>CV</code>: A new CV object containing deep copies of all fields from the input</li></ul><p><strong>Example</strong></p><p>Clone a CV object</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; copy_cv = clone(cv)
CV(&quot;replication_1&quot;, &quot;fold_1&quot;, Fit(&quot;&quot;, [&quot;&quot;, &quot;&quot;], [0.0, 0.0], &quot;&quot;, [&quot;&quot;], [&quot;&quot;], [0.0], [0.0], Dict(&quot;&quot; =&gt; 0.0), nothing), [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], Dict(&quot;&quot; =&gt; 0.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/cv.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{Fit}" href="#GBCore.clone-Tuple{Fit}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::Fit)::Fit</code></pre><p>Create a deep copy of a Fit object, duplicating all its fields.</p><p>This function performs a deep clone of the input Fit object, ensuring that all nested structures and arrays are also copied, preventing any shared references between the original and the cloned object.</p><p><strong>Arguments</strong></p><ul><li><code>x::Fit</code>: The Fit object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A new Fit object with identical but independent values</li></ul><p><strong>Fields copied</strong></p><ul><li><code>model</code>: The statistical model</li><li><code>b_hat_labels</code>: Labels for the estimated parameters</li><li><code>b_hat</code>: Estimated parameters</li><li><code>trait</code>: The trait being analyzed</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>metrics</code>: Performance metrics</li><li><code>y_true</code>: Observed values</li><li><code>y_pred</code>: Predicted values</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; copy_fit = clone(fit)
Fit(&quot;&quot;, [&quot;&quot;, &quot;&quot;], [0.0, 0.0], &quot;&quot;, [&quot;&quot;], [&quot;&quot;], [0.0], [0.0], Dict(&quot;&quot; =&gt; 0.0), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/fit.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{Genomes}" href="#GBCore.clone-Tuple{Genomes}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::Genomes)::Genomes</code></pre><p>Create a deep copy of a <code>Genomes</code> object.</p><p>This function performs a deep clone of all fields in the <code>Genomes</code> object, including:</p><ul><li>entries</li><li>populations </li><li>loci_alleles</li><li>allele_frequencies</li><li>mask</li></ul><p>Returns a new <code>Genomes</code> instance with identical but independent data.</p><p><strong>Arguments</strong></p><ul><li><code>x::Genomes</code>: The source Genomes object to clone</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes object containing deep copies of all fields</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2, p=2);

julia&gt; copy_genomes = clone(genomes)
Genomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{Phenomes}" href="#GBCore.clone-Tuple{Phenomes}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::Phenomes)::Phenomes</code></pre><p>Create a deep copy of a <code>Phenomes</code> object, including all its fields.</p><p>This function performs a deep copy of the following fields:</p><ul><li>entries: Vector of entry names</li><li>populations: Vector of population identifiers</li><li>traits: Vector of trait names</li><li>phenotypes: Matrix of phenotypic values</li><li>mask: Matrix of boolean masks</li></ul><p>Returns a new <code>Phenomes</code> object with identical structure but independent memory allocation.</p><p><strong>Arguments</strong></p><ul><li><code>x::Phenomes</code>: The source Phenomes object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes object containing deep copies of all fields</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2);

julia&gt; copy_phenomes = clone(phenomes)
Phenomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{TEBV}" href="#GBCore.clone-Tuple{TEBV}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::TEBV)::TEBV</code></pre><p>Create a deep copy of a TEBV (Trial-Estimated Breeding Value) object.</p><p>Returns a new TEBV instance with all fields deeply copied from the input object, ensuring complete independence between the original and cloned objects.</p><p><strong>Arguments</strong></p><ul><li><code>x::TEBV</code>: The source TEBV object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>TEBV</code>: A new TEBV object containing deep copies of all fields from the input</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; copy_tebv = clone(tebv);

julia&gt; copy_tebv.traits == tebv.traits
true

julia&gt; copy_tebv.phenomes == tebv.phenomes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{Trials}" href="#GBCore.clone-Tuple{Trials}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::Trials)::Trials</code></pre><p>Create a deep copy of a <code>Trials</code> object, including all its fields.</p><p>This function performs a complete deep copy of the input <code>Trials</code> object, ensuring that all nested data structures are also copied rather than referenced.</p><p><strong>Arguments</strong></p><ul><li><code>x::Trials</code>: The source <code>Trials</code> object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>Trials</code>: A new <code>Trials</code> object containing copies of all data from the input</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=2, t=2);

julia&gt; copy_trials = clone(trials)
Trials(Union{Missing, Float64}[missing missing; missing missing], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.countlevels-Tuple{DataFrames.DataFrame}" href="#GBCore.countlevels-Tuple{DataFrames.DataFrame}"><code>GBCore.countlevels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">countlevels(df::DataFrame; column_names::Vector{String})::Int64</code></pre><p>Count the total number of unique values (factor levels) across specified columns in a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Input DataFrame to analyze</li><li><code>column_names::Vector{String}</code>: Vector of column names to count unique values from</li></ul><p><strong>Returns</strong></p><ul><li><code>Int64</code>: Sum of unique values across all specified columns</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the specified column names are not found in the DataFrame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L234-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.dimensions-Tuple{Genomes}" href="#GBCore.dimensions-Tuple{Genomes}"><code>GBCore.dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimensions(genomes::Genomes)::Dict{String, Int64}</code></pre><p>Calculate various dimensional metrics of a Genomes struct.</p><p>Returns a dictionary containing the following metrics:</p><ul><li><code>&quot;n_entries&quot;</code>: Number of unique entries/samples</li><li><code>&quot;n_populations&quot;</code>: Number of unique populations</li><li><code>&quot;n_loci_alleles&quot;</code>: Total number of loci-allele combinations</li><li><code>&quot;n_chr&quot;</code>: Number of chromosomes</li><li><code>&quot;n_loci&quot;</code>: Number of unique loci across all chromosomes</li><li><code>&quot;max_n_alleles&quot;</code>: Maximum number of alleles observed at any locus</li><li><code>&quot;n_missing&quot;</code>: Count of missing values in allele frequencies</li></ul><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A valid Genomes struct containing genetic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String,Int64}</code>: Dictionary containing dimensional metrics</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Genomes struct is corrupted (fails dimension check)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; dimensions(genomes)
Dict{String, Int64} with 7 entries:
  &quot;n_entries&quot;      =&gt; 100
  &quot;n_chr&quot;          =&gt; 7
  &quot;n_loci&quot;         =&gt; 1000
  &quot;n_loci_alleles&quot; =&gt; 3000
  &quot;n_populations&quot;  =&gt; 1
  &quot;n_missing&quot;      =&gt; 0
  &quot;max_n_alleles&quot;  =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L162-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.dimensions-Tuple{Phenomes}" href="#GBCore.dimensions-Tuple{Phenomes}"><code>GBCore.dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimensions(phenomes::Phenomes)::Dict{String, Int64}</code></pre><p>Calculate various dimensional statistics of a <code>Phenomes</code> struct.</p><p>Returns a dictionary containing counts of:</p><ul><li><code>&quot;n_entries&quot;</code>: unique entries in the dataset</li><li><code>&quot;n_populations&quot;</code>: unique populations</li><li><code>&quot;n_traits&quot;</code>: number of traits</li><li><code>&quot;n_total&quot;</code>: total number of phenotypic observations (entries × traits)</li><li><code>&quot;n_zeroes&quot;</code>: number of zero values in phenotypes</li><li><code>&quot;n_missing&quot;</code>: number of missing values</li><li><code>&quot;n_nan&quot;</code>: number of NaN values</li><li><code>&quot;n_inf&quot;</code>: number of infinite values</li></ul><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String,Int64}</code>: Dictionary with dimensional statistics</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Phenomes struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; dimensions(phenomes)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 30
  &quot;n_zeroes&quot;      =&gt; 30
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 10
  &quot;n_traits&quot;      =&gt; 3
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 1
  &quot;n_missing&quot;     =&gt; 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L154-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.dimensions-Tuple{TEBV}" href="#GBCore.dimensions-Tuple{TEBV}"><code>GBCore.dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimensions(tebv::TEBV)::Dict{String, Int64}</code></pre><p>Calculate various dimensional metrics for a TEBV (Trial-Estimated Breeding Values) struct.</p><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A TEBV struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes data</li></ul><p><strong>Returns</strong></p><p>A dictionary containing the following counts:</p><ul><li><code>&quot;n_entries&quot;</code>: Number of unique entries across all phenomes</li><li><code>&quot;n_populations&quot;</code>: Number of unique populations across all phenomes</li><li><code>&quot;n_traits&quot;</code>: Number of traits in the TEBV struct</li><li><code>&quot;n_total&quot;</code>: Total number of observations across all traits</li><li><code>&quot;n_zeroes&quot;</code>: Total number of zero values across all traits</li><li><code>&quot;n_missing&quot;</code>: Total number of missing values across all traits</li><li><code>&quot;n_nan&quot;</code>: Total number of NaN values across all traits</li><li><code>&quot;n_inf&quot;</code>: Total number of Infinite values across all traits</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the TEBV struct dimensions are inconsistent or corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;trait_1&quot;], formulae=[&quot;trait_1 ~ 1 + 1|entries&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; dimensions(tebv)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 1
  &quot;n_zeroes&quot;      =&gt; 0
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 1
  &quot;n_traits&quot;      =&gt; 1
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 1
  &quot;n_missing&quot;     =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L160-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.dimensions-Tuple{Trials}" href="#GBCore.dimensions-Tuple{Trials}"><code>GBCore.dimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimensions(trials::Trials)::Dict{String, Int64}</code></pre><p>Calculate dimensional statistics of a <code>Trials</code> struct, returning a dictionary with counts of various elements.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A <code>Trials</code> struct containing trial data</li></ul><p><strong>Returns</strong></p><p>A <code>Dict{String, Int64}</code> with the following keys:</p><ul><li><code>&quot;n_traits&quot;</code>: Number of unique traits</li><li><code>&quot;n_years&quot;</code>: Number of unique years</li><li><code>&quot;n_seasons&quot;</code>: Number of unique seasons</li><li><code>&quot;n_harvests&quot;</code>: Number of unique harvests</li><li><code>&quot;n_sites&quot;</code>: Number of unique sites</li><li><code>&quot;n_replications&quot;</code>: Number of unique replications</li><li><code>&quot;n_blocks&quot;</code>: Number of unique blocks</li><li><code>&quot;n_rows&quot;</code>: Number of unique rows</li><li><code>&quot;n_cols&quot;</code>: Number of unique columns</li><li><code>&quot;n_entries&quot;</code>: Number of unique entries</li><li><code>&quot;n_populations&quot;</code>: Number of unique populations</li><li><code>&quot;n_total&quot;</code>: Total number of phenotype observations (entries × traits)</li><li><code>&quot;n_zeroes&quot;</code>: Count of zero values in phenotypes</li><li><code>&quot;n_missing&quot;</code>: Count of missing values in phenotypes</li><li><code>&quot;n_nan&quot;</code>: Count of NaN values in phenotypes</li><li><code>&quot;n_inf&quot;</code>: Count of Inf values in phenotypes</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Trials struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2);

julia&gt; trials.entries = [&quot;entry_1&quot;]; trials.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; dimensions(trials)
Dict{String, Int64} with 16 entries:
  &quot;n_zeroes&quot;       =&gt; 0
  &quot;n_harvests&quot;     =&gt; 1
  &quot;n_nan&quot;          =&gt; 0
  &quot;n_entries&quot;      =&gt; 1
  &quot;n_traits&quot;       =&gt; 2
  &quot;n_seasons&quot;      =&gt; 1
  &quot;n_rows&quot;         =&gt; 1
  &quot;n_blocks&quot;       =&gt; 1
  &quot;n_missing&quot;      =&gt; 2
  &quot;n_inf&quot;          =&gt; 0
  &quot;n_total&quot;        =&gt; 2
  &quot;n_replications&quot; =&gt; 1
  &quot;n_years&quot;        =&gt; 1
  &quot;n_sites&quot;        =&gt; 1
  &quot;n_cols&quot;         =&gt; 1
  &quot;n_populations&quot;  =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L163-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.distances-Tuple{Genomes}" href="#GBCore.distances-Tuple{Genomes}"><code>GBCore.distances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distances(
    genomes::Genomes; 
    distance_metrics::Vector{String}=[&quot;euclidean&quot;, &quot;correlation&quot;, &quot;mad&quot;, &quot;rmsd&quot;, &quot;χ²&quot;],
    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,
    include_loci_alleles::Bool = true,
    include_entries::Bool = true,
    include_counts::Bool = true,
    verbose::Bool = false
)::Tuple{Vector{String},Vector{String},Dict{String,Matrix{Float64}}}</code></pre><p>Calculate pairwise distances/similarity metrics between loci-alleles and entries in a <code>Genomes</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Input Genomes object</li><li><code>distance_metrics::Vector{String}</code>: Vector of distance metrics to calculate. Valid options:<ul><li>&quot;euclidean&quot;: Euclidean distance</li><li>&quot;correlation&quot;: Pearson correlation coefficient </li><li>&quot;mad&quot;: Mean absolute deviation</li><li>&quot;rmsd&quot;: Root mean square deviation </li><li>&quot;χ²&quot;: Chi-square distance</li></ul></li><li><code>idx_loci_alleles::Union{Nothing, Vector{Int64}}</code>: Optional indices of loci-alleles to include. If nothing, randomly samples 100 loci-alleles.</li><li><code>include_loci_alleles::Bool</code>: Whether to calculate distances between loci-alleles. Defaults to true.</li><li><code>include_entries::Bool</code>: Whether to calculate distances between entries. Defaults to true.</li><li><code>include_counts::Bool</code>: Whether to include matrices showing number of valid pairs used. Defaults to true.</li><li><code>verbose::Bool</code>: Whether to show progress bars. Defaults to false.</li></ul><p><strong>Returns</strong></p><p>Tuple containing:</p><ol><li>Vector of loci-allele names used</li><li>Vector of entry names  </li><li>Dictionary mapping &quot;{dimension}|{metric}&quot; to distance matrices, where:<ul><li>dimension is either &quot;loci_alleles&quot; or &quot;entries&quot;</li><li>metric is one of the distance metrics or &quot;counts&quot; (number of valid pairs used)</li><li>matrices contain pairwise distances/correlations (-Inf where insufficient data)</li></ul></li></ol><p><strong>Details</strong></p><ul><li>For loci-alleles, calculates distances between allele frequency profiles across entries</li><li>For entries, calculates distances between entries based on their allele frequencies</li><li>Requires at least 2 valid (non-missing, finite) pairs to calculate metrics</li><li>Includes count matrices showing number of valid pairs used per calculation</li><li>Thread-safe implementation with locks for concurrent operations</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; (loci_alleles_names, entries, dist) = distances(genomes, distance_metrics=[&quot;correlation&quot;, &quot;χ²&quot;]);

julia&gt; sort(string.(keys(dist))) == [&quot;entries|correlation&quot;, &quot;entries|counts&quot;, &quot;entries|χ²&quot;, &quot;loci_alleles|correlation&quot;, &quot;loci_alleles|counts&quot;, &quot;loci_alleles|χ²&quot;]
true

julia&gt; C = dist[&quot;entries|correlation&quot;]; C[diagind(C)] == repeat([1], length(genomes.entries))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L379-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.distances-Tuple{Phenomes}" href="#GBCore.distances-Tuple{Phenomes}"><code>GBCore.distances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distances(
    phenomes::Phenomes; 
    distance_metrics::Vector{String}=[&quot;euclidean&quot;, &quot;correlation&quot;, &quot;mad&quot;, &quot;rmsd&quot;, &quot;χ²&quot;],
    standardise_traits::Bool = false
)::Tuple{Vector{String}, Vector{String}, Dict{String, Matrix{Float64}}}</code></pre><p>Calculate pairwise distances/correlations between traits and entries in a phenotypic dataset.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>distance_metrics::Vector{String}</code>: Vector of distance metrics to compute. Valid options are:<ul><li>&quot;euclidean&quot;: Euclidean distance</li><li>&quot;correlation&quot;: Pearson correlation coefficient</li><li>&quot;mad&quot;: Mean absolute deviation</li><li>&quot;rmsd&quot;: Root mean square deviation</li><li>&quot;χ²&quot;: Chi-square distance</li></ul></li><li><code>standardise_traits::Bool</code>: If true, standardizes traits to mean=0 and sd=1 before computing distances</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li>Vector of trait names</li><li>Vector of entry names</li><li>Dictionary mapping &quot;{dimension}|{metric}&quot; to distance matrices, where:<ul><li>dimension ∈ [&quot;traits&quot;, &quot;entries&quot;]</li><li>metric ∈ distance_metrics ∪ [&quot;counts&quot;]</li><li>&quot;counts&quot; matrices contain the number of non-missing pairs used in calculations</li></ul></li></ol><p><strong>Notes</strong></p><ul><li>Pairs with fewer than 2 non-missing values result in -Inf distance values</li><li>For correlation calculations, traits with near-zero variance (&lt; 1e-7) are skipped</li><li>χ² distance adds machine epsilon to denominator to avoid division by zero</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[2,2] = missing;

julia&gt; (traits, entries, dist) = distances(phenomes, distance_metrics=[&quot;correlation&quot;, &quot;χ²&quot;]);

julia&gt; sort(string.(keys(dist))) == [&quot;entries|correlation&quot;, &quot;entries|counts&quot;, &quot;entries|χ²&quot;, &quot;traits|correlation&quot;, &quot;traits|counts&quot;, &quot;traits|χ²&quot;]
true

julia&gt; C = dist[&quot;entries|correlation&quot;]; C[diagind(C)] == repeat([1], length(phenomes.entries))
true

julia&gt; dist[&quot;traits|counts&quot;][:, 2] == dist[&quot;traits|counts&quot;][2, :] == repeat([9], length(phenomes.traits))
true

julia&gt; dist[&quot;entries|counts&quot;][:, 2] == dist[&quot;entries|counts&quot;][2, :] == repeat([2], length(phenomes.entries))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L211-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.extractphenomes-Tuple{TEBV}" href="#GBCore.extractphenomes-Tuple{TEBV}"><code>GBCore.extractphenomes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractphenomes(tebv::TEBV)::Phenomes</code></pre><p>Extract phenotypic values from a Trial-Estimated Breeding Value (TEBV) object.</p><p>This function processes phenotypic data from a TEBV object, handling intercept effects and merging multiple phenomes if present. It performs the following operations:</p><ol><li>Validates input TEBV dimensions</li><li>Processes intercept effects if present by:<ul><li>Identifying intercept terms</li><li>Combining intercept values with trait effects</li><li>Adjusting trait names and phenotypic values accordingly</li></ul></li><li>Merges multiple phenomes if present</li><li>Renames traits to match input TEBV traits if dimensions align</li><li>Validates output Phenomes dimensions</li></ol><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A Trial Estimated Breeding Value object containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A Phenomes object containing processed phenotypic values</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input TEBV or output Phenomes dimensions are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);

julia&gt; tebv = analyse(trials, max_levels=50, verbose=false);

julia&gt; phenomes = extractphenomes(tebv);

julia&gt; phenomes.traits == [&quot;trait_1&quot;, &quot;trait_2&quot;, &quot;trait_3&quot;]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L1050-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.extractphenomes-Tuple{Trials}" href="#GBCore.extractphenomes-Tuple{Trials}"><code>GBCore.extractphenomes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractphenomes(trials::Trials)::Phenomes</code></pre><p>Convert a <code>Trials</code> struct into a <code>Phenomes</code> struct by extracting phenotypic values across different environments.</p><p><strong>Details</strong></p><ul><li>Combines trait measurements with their environmental contexts</li><li>Creates unique trait identifiers by combining trait names with environment variables</li><li>Environment variables include: years, harvests, seasons, sites, and replications</li><li>For single environment scenarios, trait names remain without environmental suffixes</li></ul><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing phenotypic measurements across different environments</li></ul><p><strong>Returns</strong></p><ul><li>A Phenomes struct containing:<ul><li><code>phenotypes</code>: Matrix of phenotypic values (entries × traits)</li><li><code>entries</code>: Vector of entry names</li><li><code>populations</code>: Vector of population names</li><li><code>traits</code>: Vector of trait names (with environmental contexts)</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If duplicate entries exist within year-harvest-season-site-replication combinations</li><li><code>ErrorException</code>: If dimensional validation fails during Phenomes construction</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; size(phenomes.phenotypes)
(100, 384)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L305-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.loci-Tuple{Genomes}" href="#GBCore.loci-Tuple{Genomes}"><code>GBCore.loci</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loci(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{Int64},Vector{Int64}}</code></pre><p>Extract genomic positional information from a <code>Genomes</code> object, returning a tuple of vectors containing chromosome names, positions, and locus boundary indices.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes object containing genomic data</li><li><code>verbose::Bool = false</code>: If true, displays a progress bar during computation</li></ul><p><strong>Returns</strong></p><p>A tuple containing four vectors:</p><ul><li><code>chromosomes::Vector{String}</code>: Names of chromosomes</li><li><code>positions::Vector{Int64}</code>: Positions within chromosomes</li><li><code>loci_ini_idx::Vector{Int64}</code>: Starting indices for each locus</li><li><code>loci_fin_idx::Vector{Int64}</code>: Ending indices for each locus</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; chromosomes, positions, loci_ini_idx, loci_fin_idx = loci(genomes);

julia&gt; length(chromosomes), length(positions), length(loci_ini_idx), length(loci_fin_idx)
(1000, 1000, 1000, 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L308-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.loci_alleles-Tuple{Genomes}" href="#GBCore.loci_alleles-Tuple{Genomes}"><code>GBCore.loci_alleles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loci_alleles(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{String}}</code></pre><p>Extract chromosomes, positions, and alleles information from a <code>Genomes</code> object.</p><p>Returns a tuple of three vectors containing:</p><ol><li>Chromosomes identifiers as strings</li><li>Base-pair positions as integers</li><li>Allele identifiers as strings</li></ol><p>Each vector has length equal to the total number of loci-allele combinations in the genome.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A valid Genomes object containing loci and allele information</li><li><code>verbose::Bool = false</code>: If true, displays a progress bar during extraction</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{String},Vector{Int64},Vector{String}}</code>: A tuple containing three vectors:<ul><li>chromosomes: Vector of chromosome identifiers</li><li>positions: Vector of base-pair positions</li><li>alleles: Vector of allele identifiers</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Genomes struct dimensions are invalid or corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; chromosomes, positions, alleles = loci_alleles(genomes);

julia&gt; length(chromosomes), length(positions), length(alleles)
(3000, 3000, 3000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L245-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.plot" href="#GBCore.plot"><code>GBCore.plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(genomes::Genomes, seed::Int64 = 42)::Nothing</code></pre><p>Generate visualization plots for allele frequencies in genomic data.</p><p>For each population in the dataset, creates three plots:</p><ol><li>Histogram of per-entry allele frequencies</li><li>Histogram of mean allele frequencies per locus</li><li>Correlation heatmap of allele frequencies between loci</li></ol><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing allele frequency data</li><li><code>seed::Int64=42</code>: Random seed for reproducibility of sampling loci</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: Displays plots but doesn&#39;t return any value</li></ul><p><strong>Notes</strong></p><ul><li>Uses up to 100 randomly sampled loci for visualization</li><li>Handles missing values in the data</li><li>Displays folded frequency spectra (both q and 1-q)</li><li>Will throw ArgumentError if the Genomes struct is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; GBCore.plot(genomes)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L629-L659">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.plot" href="#GBCore.plot"><code>GBCore.plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(fit::Fit, distribution::Any=[TDist(1), Normal()][2], α::Float64=0.05)</code></pre><p>Generate diagnostic plots for genetic association analysis results.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: A Fit object containing the association analysis results, specifically the <code>b_hat</code> field with effect sizes</li><li><code>distribution::Any</code>: The null distribution for p-value calculation. Defaults to Normal distribution</li><li><code>α::Float64</code>: Significance level for multiple testing correction (Bonferroni). Defaults to 0.05</li></ul><p><strong>Returns</strong></p><p>Displays three plots:</p><ul><li>Histogram showing the distribution of effect sizes</li><li>Manhattan plot showing -log10(p-values) across loci with Bonferroni threshold</li><li>Q-Q plot comparing observed vs expected -log10(p-values)</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; distribution = [TDist(1), Normal()][2];

julia&gt; fit = Fit(n=100, l=10_000); fit.b_hat = rand(distribution, 10_000);  α = 0.05;

julia&gt; GBCore.plot(fit);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/fit.jl#L163-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.plot-Tuple{Phenomes}" href="#GBCore.plot-Tuple{Phenomes}"><code>GBCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(phenomes::Phenomes; nbins::Int64 = 10)::Nothing</code></pre><p>Generate diagnostic plots for phenotypic data stored in a <code>Phenomes</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>nbins::Int64=10</code>: Number of bins for the histograms (optional)</li></ul><p><strong>Description</strong></p><p>For each population in the dataset:</p><ol><li>Creates histograms showing the distribution of each trait</li><li>Generates a heatmap of trait correlations for traits with non-zero variance</li></ol><p><strong>Notes</strong></p><ul><li>Skips traits with all missing, NaN, or infinite values</li><li>Only includes traits with variance &gt; 1e-10 in correlation analysis</li><li>Requires at least 3 data points to generate a histogram</li><li>Uses UnicodePlots for visualization in terminal</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3);

julia&gt; GBCore.plot(phenomes);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L436-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.plot-Tuple{TEBV}" href="#GBCore.plot-Tuple{TEBV}"><code>GBCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(tebv::TEBV)</code></pre><p>Create a visualization of True Estimated Breeding Values (TEBV) analysis results.</p><p>This function extracts phenomes from the TEBV object and generates a plot to visualize the breeding value estimates.</p><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A TEBV object containing the analysis results</li></ul><p><strong>Returns</strong></p><ul><li>A plot object representing the visualization of the phenomes data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L1138-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.plot-Tuple{Trials}" href="#GBCore.plot-Tuple{Trials}"><code>GBCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(trials::Trials; nbins::Int64 = 10)::Nothing</code></pre><p>Generate a comprehensive visualization of trial data through histograms, correlation heatmaps, and bar plots.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing the trial data to be visualized</li><li><code>nbins::Int64=10</code>: Number of bins for the histogram plots (optional)</li></ul><p><strong>Details</strong></p><p>The function creates three types of plots:</p><ol><li>Histograms for each trait within each population, showing the distribution of trait values</li><li>Correlation heatmaps between traits for each population</li><li>Bar plots showing mean trait values across different trial factors:<ul><li>Years</li><li>Seasons</li><li>Harvests</li><li>Sites</li><li>Replications</li><li>Rows</li><li>Columns</li><li>Populations</li></ul></li></ol><p>Missing, NaN, or infinite values are automatically filtered out before plotting.</p><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: The function displays plots but does not return any value</li></ul><p><strong>Notes</strong></p><ul><li>Requires valid trial data with non-zero variance for correlation plots</li><li>Uses UnicodePlots for visualization in terminal</li><li>Skips plotting for traits with insufficient data points</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; GBCore.plot(trials);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L475-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.simulateeffects-Tuple{}" href="#GBCore.simulateeffects-Tuple{}"><code>GBCore.simulateeffects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Simulate effects</strong></p><p>Sample <code>p</code> x <code>q</code> effects from a multivariate normal distribution with <code>μ~Exp(λ)</code> and <code>Σ=μμ&#39;</code></p><p><strong>Arguments</strong></p><ul><li><code>p</code>: number of correlated effects to simulate (default = 2)</li><li><code>q</code>: number times to simulate the correlated effects from the same distribution (default = 1)</li><li><code>λ</code>: parameter of the exponential distritbution from which the means will be sampled from (default = 1.00)</li><li><code>seed</code>: randomisation seed (default = 42)</li></ul><p><strong>Output</strong></p><ul><li><code>p</code> x <code>q</code> matrix of correlated effects</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; θ::Matrix{Float64} = simulateeffects();

julia&gt; sum(abs.(θ - [-0.0886501800782904; -0.596478483888422])) &lt; 0.00001
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_effects.jl#L168-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.simulategenomes-Tuple{}" href="#GBCore.simulategenomes-Tuple{}"><code>GBCore.simulategenomes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Simulate genomes</strong></p><p><strong>Arguments</strong></p><ul><li><code>n</code>: number of entries (default = 100)</li><li><code>l</code>: number of loci (default = 10_000)</li><li><code>n_chroms</code>: number of chromosomes (default = 7)</li><li><code>n_alleles</code>: number of alleles per locus (default = 2)</li><li><code>max_pos</code>: total length of the genome in base-pairs (bp) (default = 135<em>000</em>000)</li><li><code>ld_corr_50perc_kb</code>: distance in bp at which linkage expressed as correlation between a pair of loci is at 50% (default = 1_000)</li><li><code>μ_β_params</code>: the shape parameters of the Beta distribution from which the mean allele frequencies will be sampled  (default = (0.5, 0.5); U-shaped distribution; you may use (2.0, 2.0) for a bell-shaped distribution)</li><li><code>sparsity</code>: Proportion of missing data (default = 0.0)</li><li><code>seed</code>: psuedo-random number generator seed for replicability (default = 42)</li><li><code>verbose</code>: Show progress bar and plot the linkage heatmap into an svg file? (default = true)</li></ul><p><strong>Output</strong></p><ul><li><code>Genomes</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=10_000, n_alleles=3, verbose=false);

julia&gt; length(genomes.entries)
100

julia&gt; length(genomes.populations)
100

julia&gt; length(genomes.loci_alleles)
20000

julia&gt; size(genomes.allele_frequencies)
(100, 20000)

julia&gt; mean(ismissing.(genomes.allele_frequencies))
0.0

julia&gt; rng::TaskLocalRNG = Random.seed!(123);

julia&gt; idx = StatsBase.sample(rng, range(1, 20_000, step=2), 250, replace = false, ordered = true);

julia&gt; correlations = StatsBase.cor(genomes.allele_frequencies[:, idx]);

julia&gt; correlations[10,10] == 1.00
true

julia&gt; correlations[10,10] &gt; correlations[10,250]
true

julia&gt; genomes = simulategenomes(n=100, l=10_000, n_alleles=3, sparsity=0.25, verbose=false);

julia&gt; mean(ismissing.(genomes.allele_frequencies))
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_genomes.jl#L1-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.simulategenomiceffects-Tuple{}" href="#GBCore.simulategenomiceffects-Tuple{}"><code>GBCore.simulategenomiceffects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Simulate genomic effects</strong></p><p>Simulate additive, dominance, and epistatic effects</p><p><strong>Arguments</strong></p><ul><li><code>genomes</code>: Genome struct includes the <code>n</code> entries x <code>p</code> loci-alleles combinations (<code>p</code> = <code>l</code> loci x <code>a-1</code> alleles)</li><li><code>f_additive</code>: proportion of the <code>l</code> loci with non-zero additive effects on the phenotype</li><li><code>f_dominance</code>: proportion of the <code>l*f_additive</code> additive effects loci with additional dominance effects</li><li><code>f_epistasis</code>: proportion of the <code>l*f_additive</code> additive effects loci with additional epistasis effects</li></ul><p><strong>Outputs</strong></p><ul><li><code>n</code> x <code>3</code> matrix of additive, dominance and epistasis effects per entry</li><li><code>p</code> x <code>3</code> matrix of additive, dominance and epistasis effects per locus-allele combination</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);

julia&gt; G, B = simulategenomiceffects(genomes=genomes, f_additive=0.05, f_dominance=0.75, f_epistasis=0.25);

julia&gt; size.([G, B])
2-element Vector{Tuple{Int64, Int64}}:
 (100, 3)
 (4000, 3)

julia&gt; sum(B .!= 0.0, dims=1)
1×3 Matrix{Int64}:
 200  75  50</code></pre><p><strong>Details</strong></p><p>The additive, dominance, and epistasis allele effects share a common exponential distribution (<code>λ=1</code>) from which  the mean of the effects (<code>μ</code>) are sampled, and the covariance matrix is derived (<code>Σ = μ * μ&#39;</code>;  where if <code>det(Σ)≈0</code> then we iteratively add 1.00 to the diagonals until it becomes invertible or 10 iterations  finishes and throws an error). The non-additive or epistasis allele effects were simulated by multiplying the allele  frequencies of all possible unique pairs of epistasis alleles and their effects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_effects.jl#L213-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.simulatetrials-Tuple{}" href="#GBCore.simulatetrials-Tuple{}"><code>GBCore.simulatetrials</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Simulate trials</strong></p><p><strong>Arguments</strong></p><ul><li><code>genomes</code>: Genome struct includes the <code>n</code> entries x <code>p</code> loci-alleles combinations (<code>p</code> = <code>l</code> loci x <code>a-1</code> alleles)</li><li><code>f_add_dom_epi</code>: <code>n_traits</code> x 3 numeric matrix of loci proportion with additive, dominance and epistasis effects, i.e. each column refers to:<ul><li><code>f_additive</code>: proportion of the <code>l</code> loci with non-zero additive effects on the phenotype</li><li><code>f_dominance</code>: proportion of the <code>l*f_additive</code> additive effects loci with additional dominance effects</li><li><code>f_epistasis</code>: proportion of the <code>l*f_additive</code> additive effects loci with additional epistasis effects</li><li>(default = [0.01 0.25 0.10; 0.05 0.50 0.25; 0.10 0.25 0.00])</li></ul></li><li><code>n_years</code>: Number of years (default = 2)</li><li><code>n_seasons</code>: Number of seasons (default = 4)</li><li><code>n_harvests</code>: Number of harvests (default = 2)</li><li><code>n_sites</code>: Number of sites (default = 4)</li><li><code>n_replications</code>: Number of replications (default = 2)</li><li><code>n_blocks</code>: Number of blocks across the entire field layout (default = missing)</li><li><code>n_rows</code>: Number of rows across the entire field layout (default = missing)</li><li><code>n_cols</code>: Number of columns across the entire field layout (default = missing)</li><li><code>proportion_of_variance</code>: <code>9</code> x <code>n_traits</code> numeric matrix of scaled/non-scaled proportion of variances allocated to   genetic and environmental effects (default = missing; values will be sampled from a uniform distribution  followed by a biased sample on the first row, i.e. additive effects row).  The rows correspond to the variance allocated to:<ol><li>additive genetic effects</li><li>dominance genetic effects</li><li>epistasis genetic effects</li><li>years effects</li><li>seasons effects</li><li>sites effects</li><li>environmental interactions</li><li>spatial interactions</li><li>GxE interactiions</li></ol></li><li><code>seed</code>: Randomisation seed (default = 42)</li><li><code>sparsity</code>: Proportion of missing data (default = 0.0)</li><li><code>verbose</code>: Show trials simulation progress bar? (default = true)</li></ul><p><strong>Outputs</strong></p><ul><li><code>Trials</code> struct of simulated phenotype data</li><li>Vector of <code>SimulatedEffects</code> each corresponding to each trait-year-season-harvest-site-replication combination</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);

julia&gt; trials::Trials, vector_of_effects::Array{SimulatedEffects,1} = simulatetrials(genomes=genomes, sparsity=0.25, verbose=false);

julia&gt; size(trials.phenotypes)
(12800, 3)

julia&gt; size(trials.traits)
(3,)

julia&gt; unique(trials.entries) == genomes.entries
true

julia&gt; unique(trials.populations) == unique(genomes.populations)
true

julia&gt; abs(mean(ismissing.(trials.phenotypes)) - 0.25) &lt; 0.00001
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/simulation/simulate_trials.jl#L1-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.slice-Tuple{Genomes}" href="#GBCore.slice-Tuple{Genomes}"><code>GBCore.slice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slice(
    genomes::Genomes; 
    idx_entries::Union{Nothing, Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,
    verbose::Bool = false
)::Genomes</code></pre><p>Create a subset of a <code>Genomes</code> struct by selecting specific entries and loci-allele combinations.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: The source genomic data structure to be sliced</li><li><code>idx_entries::Union{Nothing, Vector{Int64}}</code>: Indices of entries to keep. If <code>nothing</code>, all entries are kept</li><li><code>idx_loci_alleles::Union{Nothing, Vector{Int64}}</code>: Indices of loci-allele combinations to keep. If <code>nothing</code>, all loci-alleles are kept</li><li><code>verbose::Bool</code>: If true, displays a progress bar during slicing. Defaults to false</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new <code>Genomes</code> struct containing only the selected entries and loci-allele combinations</li></ul><p><strong>Notes</strong></p><ul><li>Both index vectors are automatically sorted and deduplicated</li><li>Indices must be within valid ranges (1 to n<em>entries or n</em>loci_alleles)</li><li>The function preserves the structure and relationships of the original data</li><li>Thread-safe implementation with locks for concurrent operations</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the input <code>Genomes</code> struct is corrupted or if indices are out of bounds</li><li><code>DimensionMismatch</code>: If the resulting sliced genome has inconsistent dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; sliced_genomes = slice(genomes, idx_entries=collect(1:10), idx_loci_alleles=collect(1:300));

julia&gt; dimensions(sliced_genomes)
Dict{String, Int64} with 7 entries:
  &quot;n_entries&quot;      =&gt; 10
  &quot;n_chr&quot;          =&gt; 1
  &quot;n_loci&quot;         =&gt; 100
  &quot;n_loci_alleles&quot; =&gt; 300
  &quot;n_populations&quot;  =&gt; 1
  &quot;n_missing&quot;      =&gt; 0
  &quot;max_n_alleles&quot;  =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/genomes.jl#L737-L782">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.slice-Tuple{Phenomes}" href="#GBCore.slice-Tuple{Phenomes}"><code>GBCore.slice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slice(phenomes::Phenomes; idx_entries::Union{Nothing, Vector{Int64}}=nothing, idx_traits::Union{Nothing, Vector{Int64}}=nothing)::Phenomes</code></pre><p>Create a new <code>Phenomes</code> object containing a subset of the original data by selecting specific entries and traits.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: The original Phenomes object to slice</li><li><code>idx_entries::Union{Nothing, Vector{Int64}}=nothing</code>: Indices of entries to keep. If <code>nothing</code>, all entries are kept</li><li><code>idx_traits::Union{Nothing, Vector{Int64}}=nothing</code>: Indices of traits to keep. If <code>nothing</code>, all traits are kept</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes object containing only the selected entries and traits</li></ul><p><strong>Notes</strong></p><ul><li>The function preserves the original structure while reducing dimensions</li><li>Indices must be within valid ranges (1 to n<em>entries/n</em>traits)</li><li>Duplicate indices are automatically removed</li><li>The resulting object maintains all relationships between entries, populations, traits, and phenotypes</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the input Phenomes struct is corrupted or if indices are out of bounds</li><li><code>DimensionMismatch</code>: If the slicing operation results in invalid dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; sliced_phenomes = slice(phenomes, idx_entries=collect(1:5); idx_traits=collect(2:3));

julia&gt; dimensions(sliced_phenomes)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 10
  &quot;n_zeroes&quot;      =&gt; 10
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 5
  &quot;n_traits&quot;      =&gt; 2
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 1
  &quot;n_missing&quot;     =&gt; 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L534-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.slice-Tuple{Trials}" href="#GBCore.slice-Tuple{Trials}"><code>GBCore.slice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slice(
    trials::Trials; 
    traits::Union{Nothing, Vector{String}} = nothing,
    populations::Union{Nothing, Vector{String}} = nothing,
    entries::Union{Nothing, Vector{String}} = nothing,
    years::Union{Nothing, Vector{String}} = nothing,
    harvests::Union{Nothing, Vector{String}} = nothing,
    seasons::Union{Nothing, Vector{String}} = nothing,
    sites::Union{Nothing, Vector{String}} = nothing,
    replications::Union{Nothing, Vector{String}} = nothing,
    blocks::Union{Nothing, Vector{String}} = nothing,
    rows::Union{Nothing, Vector{String}} = nothing,
    cols::Union{Nothing, Vector{String}} = nothing,
)::Trials</code></pre><p>Create a subset of a <code>Trials</code> struct by filtering its components based on specified criteria.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: The source trials data structure to be sliced</li><li><code>traits::Vector{String}</code>: Selected trait names to include</li><li><code>populations::Vector{String}</code>: Selected population names to include</li><li><code>entries::Vector{String}</code>: Selected entry names to include</li><li><code>years::Vector{String}</code>: Selected years to include</li><li><code>harvests::Vector{String}</code>: Selected harvest identifiers to include</li><li><code>seasons::Vector{String}</code>: Selected seasons to include</li><li><code>sites::Vector{String}</code>: Selected site names to include</li><li><code>replications::Vector{String}</code>: Selected replication identifiers to include</li><li><code>blocks::Vector{String}</code>: Selected block identifiers to include</li><li><code>rows::Vector{String}</code>: Selected row identifiers to include</li><li><code>cols::Vector{String}</code>: Selected column identifiers to include</li></ul><p>All arguments except <code>trials</code> are optional. When an argument is not provided (i.e., <code>nothing</code>),  all values for that category are included in the slice.</p><p><strong>Returns</strong></p><ul><li>A new <code>Trials</code> struct containing only the selected data</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If invalid names are provided for any category or if no data remains after filtering</li><li><code>DimensionMismatch</code>: If the resulting sliced trials structure has inconsistent dimensions</li><li><code>ArgumentError</code>: If the input trials structure is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; sliced_trials = slice(trials, traits=trials.traits[2:3], years=[unique(trials.years)[1]], seasons=unique(trials.seasons)[2:3]);

julia&gt; dimensions(sliced_trials)
Dict{String, Int64} with 16 entries:
  &quot;n_zeroes&quot;       =&gt; 0
  &quot;n_harvests&quot;     =&gt; 2
  &quot;n_nan&quot;          =&gt; 0
  &quot;n_entries&quot;      =&gt; 100
  &quot;n_traits&quot;       =&gt; 2
  &quot;n_seasons&quot;      =&gt; 2
  &quot;n_blocks&quot;       =&gt; 10
  &quot;n_rows&quot;         =&gt; 10
  &quot;n_missing&quot;      =&gt; 0
  &quot;n_inf&quot;          =&gt; 0
  &quot;n_total&quot;        =&gt; 6400
  &quot;n_replications&quot; =&gt; 2
  &quot;n_years&quot;        =&gt; 1
  &quot;n_sites&quot;        =&gt; 4
  &quot;n_cols&quot;         =&gt; 20
  &quot;n_populations&quot;  =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L598-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.summarise-Tuple{Vector{CV}}" href="#GBCore.summarise-Tuple{Vector{CV}}"><code>GBCore.summarise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">summarise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}</code></pre><p>Summarize cross-validation results from a vector of CV structs into two DataFrames.</p><p><strong>Returns</strong></p><ul><li>A tuple containing two DataFrames:<ol><li>Summary DataFrame with mean metrics across entries, replications, and folds<ul><li>Contains means and standard deviations of correlation coefficients</li><li>Includes average training and validation set sizes</li><li>Grouped by training population, validation population, trait, and model</li></ul></li><li>Entry-level DataFrame with phenotype prediction statistics<ul><li>Contains true phenotype values, predicted means (μ), and standard deviations (σ)</li><li>Grouped by training population, validation population, trait, model, and entry</li></ul></li></ol></li></ul><p><strong>Arguments</strong></p><ul><li><code>cvs::Vector{CV}</code>: Vector of CV structs containing cross-validation results</li></ul><p><strong>Notes</strong></p><ul><li>Validates dimensions of input CV structs before processing</li><li>Handles missing values in phenotype predictions</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any CV struct in the input vector has inconsistent dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(&quot;cor&quot; =&gt; 0.0, &quot;rmse&quot; =&gt; 1.0); fit_1.trait = &quot;trait_1&quot;;

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit_1, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit_1.metrics);

julia&gt; fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(&quot;cor&quot; =&gt; 1.0, &quot;rmse&quot; =&gt; 0.0); fit_2.trait = &quot;trait_1&quot;;

julia&gt; cv_2 = CV(&quot;replication_2&quot;, &quot;fold_2&quot;, fit_2, [&quot;population_2&quot;], [&quot;entry_2&quot;], [0.0], [0.0], fit_2.metrics);

julia&gt; cvs = [cv_1, cv_2];

julia&gt; df_summary, df_summary_per_entry = summarise(cvs);

julia&gt; size(df_summary)
(2, 8)

julia&gt; size(df_summary_per_entry)
(2, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/cv.jl#L355-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.tabularise" href="#GBCore.tabularise"><code>GBCore.tabularise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tabularise(fit::Fit, metric::String = &quot;cor&quot;)::DataFrame</code></pre><p>Convert a Fit struct into a DataFrame for easier data manipulation and analysis.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: A Fit struct containing model results and parameters</li><li><code>metric::String = &quot;cor&quot;</code>: The metric to extract from fit.metrics dictionary (default: &quot;cor&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame with the following columns:<ul><li><code>model</code>: The model name</li><li><code>trait</code>: The trait name</li><li><code>population</code>: Semicolon-separated string of unique population names</li><li><code>metric</code>: The specified metric value from fit.metrics</li><li><code>b_hat_labels</code>: Labels for the effect sizes</li><li><code>b_hat</code>: Estimated effect sizes</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=100, l=10_000); fit.b_hat = rand(10_000); fit.model=&quot;some_model&quot;; fit.trait=&quot;some_trait&quot;; 

julia&gt; fit.metrics = Dict(&quot;cor&quot; =&gt; rand(), &quot;rmse&quot; =&gt; rand()); fit.populations .= &quot;pop_1&quot;;

julia&gt; df = tabularise(fit);

julia&gt; size(df)
(10000, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/fit.jl#L208-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.tabularise-Tuple{Phenomes}" href="#GBCore.tabularise-Tuple{Phenomes}"><code>GBCore.tabularise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tabularise(phenomes::Phenomes)::DataFrame</code></pre><p>Convert a <code>Phenomes</code> struct into a tabular format as a <code>DataFrame</code>.</p><p>The resulting DataFrame contains the following columns:</p><ul><li><code>id</code>: Integer index for each entry</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population assignments</li><li>Additional columns for each trait in <code>phenomes.traits</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A valid Phenomes struct containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame with entries as rows and traits as columns</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Phenomes struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; tabularise(phenomes)
10×6 DataFrame
 Row │ id     entries   populations  A         B         C        
     │ Int64  String    String       Float64?  Float64?  Float64? 
─────┼────────────────────────────────────────────────────────────
   1 │     1  entry_1   pop_1             0.0       0.0       0.0
   2 │     2  entry_2   pop_1             0.0       0.0       0.0
   3 │     3  entry_3   pop_1             0.0       0.0       0.0
   4 │     4  entry_4   pop_1             0.0       0.0       0.0
   5 │     5  entry_5   pop_1             0.0       0.0       0.0
   6 │     6  entry_6   pop_1             0.0       0.0       0.0
   7 │     7  entry_7   pop_1             0.0       0.0       0.0
   8 │     8  entry_8   pop_1             0.0       0.0       0.0
   9 │     9  entry_9   pop_1             0.0       0.0       0.0
  10 │    10  entry_10  pop_1             0.0       0.0       0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L836-L876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.tabularise-Tuple{Trials}" href="#GBCore.tabularise-Tuple{Trials}"><code>GBCore.tabularise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tabularise(trials::Trials)::DataFrame</code></pre><p>Convert a Trials struct into a DataFrame representation for easier data manipulation and analysis.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A valid Trials struct containing experimental field trial data.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame with the following columns:<ul><li><code>id</code>: Unique identifier for each trial observation</li><li><code>years</code>: Year of the trial</li><li><code>seasons</code>: Season identifier</li><li><code>harvests</code>: Harvest identifier</li><li><code>sites</code>: Location/site identifier</li><li><code>replications</code>: Replication number</li><li><code>blocks</code>: Block identifier</li><li><code>rows</code>: Row position</li><li><code>cols</code>: Column position</li><li><code>entries</code>: Entry identifier</li><li><code>populations</code>: Population identifier</li><li>Additional columns for each trait in <code>trials.traits</code></li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Trials struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; df = tabularise(trials);

julia&gt; size(df)
(12800, 14)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/trials.jl#L244-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.tabularise-Tuple{Vector{CV}}" href="#GBCore.tabularise-Tuple{Vector{CV}}"><code>GBCore.tabularise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tabularise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}</code></pre><p>Convert a vector of CV (Cross-Validation) structs into two DataFrames containing metrics and predictions.</p><p><strong>Arguments</strong></p><ul><li><code>cvs::Vector{CV}</code>: Vector of CV structs containing cross-validation results</li></ul><p><strong>Returns</strong></p><ul><li><p><code>Tuple{DataFrame,DataFrame}</code>: A tuple of two DataFrames:</p><ol><li><p><code>df_across_entries</code>: Contains aggregated metrics across entries with columns:</p><ul><li><code>training_population</code>: Semicolon-separated list of training populations</li><li><code>validation_population</code>: Semicolon-separated list of validation populations</li><li><code>trait</code>: Name of the trait</li><li><code>model</code>: Name of the model used</li><li><code>replication</code>: Replication identifier</li><li><code>fold</code>: Fold identifier</li><li><code>training_size</code>: Number of entries in training set</li><li><code>validation_size</code>: Number of entries in validation set</li><li>Additional columns for each metric (e.g., <code>cor</code>, <code>rmse</code>)</li></ul></li><li><p><code>df_per_entry</code>: Contains per-entry predictions with columns:</p><ul><li><code>training_population</code>: Training population identifier</li><li><code>validation_population</code>: Validation population identifier</li><li><code>entry</code>: Entry identifier</li><li><code>trait</code>: Name of the trait</li><li><code>model</code>: Name of the model used</li><li><code>replication</code>: Replication identifier</li><li><code>fold</code>: Fold identifier</li><li><code>y_true</code>: True values</li><li><code>y_pred</code>: Predicted values</li></ul></li></ol></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input vector is empty or if any CV struct is corrupted</li></ul><p><strong>Notes</strong></p><ul><li>Warns if there are empty CV structs resulting from insufficient training sizes or fixed traits</li><li>Metrics are extracted from the <code>metrics</code> dictionary in each CV struct</li><li>Population identifiers are sorted and joined with semicolons when multiple populations exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(&quot;cor&quot; =&gt; 0.0, &quot;rmse&quot; =&gt; 1.0); fit_1.trait = &quot;trait_1&quot;;

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit_1, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit_1.metrics);

julia&gt; fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(&quot;cor&quot; =&gt; 1.0, &quot;rmse&quot; =&gt; 0.0); fit_2.trait = &quot;trait_1&quot;;

julia&gt; cv_2 = CV(&quot;replication_2&quot;, &quot;fold_2&quot;, fit_2, [&quot;population_2&quot;], [&quot;entry_2&quot;], [0.0], [0.0], fit_2.metrics);

julia&gt; cvs = [cv_1, cv_2];

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; names(df_across_entries)
10-element Vector{String}:
 &quot;training_population&quot;
 &quot;validation_population&quot;
 &quot;trait&quot;
 &quot;model&quot;
 &quot;replication&quot;
 &quot;fold&quot;
 &quot;training_size&quot;
 &quot;validation_size&quot;
 &quot;cor&quot;
 &quot;rmse&quot;

julia&gt; df_across_entries[!, [:cor, :rmse]]
2×2 DataFrame
 Row │ cor      rmse    
     │ Float64  Float64 
─────┼──────────────────
   1 │     0.0      1.0
   2 │     1.0      0.0

julia&gt; names(df_per_entry)
9-element Vector{String}:
 &quot;training_population&quot;
 &quot;validation_population&quot;
 &quot;entry&quot;
 &quot;trait&quot;
 &quot;model&quot;
 &quot;replication&quot;
 &quot;fold&quot;
 &quot;y_true&quot;
 &quot;y_pred&quot;

julia&gt; df_per_entry[!, [:entry, :y_true, :y_pred]]
2×3 DataFrame
 Row │ entry    y_true   y_pred  
     │ String   Float64  Float64 
─────┼───────────────────────────
   1 │ entry_1      0.0      0.0
   2 │ entry_2      0.0      0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/cv.jl#L168-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}" href="#GBCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}"><code>GBCore.trialsmodelsfomulae!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trialsmodelsfomulae!(df::DataFrame; trait::String, max_levels::Int64 = 100)::Tuple{Vector{String},Vector{Int64}}</code></pre><p>Generate mixed model formulae for analyzing multi-environment trial data.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Input DataFrame containing trial data, will be modified in-place</li><li><code>trait::String</code>: Name of the response variable column</li><li><code>max_levels::Int64=100</code>: Maximum number of factor levels allowed in interaction terms</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>Vector{String}</code>: Collection of mixed model formulae with increasing complexity</li><li><code>Vector{Int64}</code>: Corresponding number of factor levels for each formula</li></ul><p><strong>Details</strong></p><p>The function:</p><ol><li>Identifies available trial design variables (nesters, spatial components, targets)</li><li>Creates interaction terms between variables and adds them to the DataFrame</li><li>Generates model formulae considering:<ul><li>Single and multi-environment models</li><li>Fixed and random entry effects</li><li>Spatial error components</li><li>Nested random effects</li></ul></li><li>Filters redundant models and sorts by complexity</li></ol><p><strong>Notes</strong></p><ul><li>Warns if trials are unreplicated</li><li>Throws error if only one entry is present</li><li>Automatically removes block effects when both row and column effects are present</li><li>Removes redundant nesting structures</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _simulated_effects = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; df = tabularise(trials);

julia&gt; size(df)
(12800, 14)

julia&gt; formulae, n_levels = trialsmodelsfomulae!(df, trait=&quot;trait_1&quot;);

julia&gt; size(df)
(12800, 134)

julia&gt; length(formulae)
76

julia&gt; sum(n_levels .== sort(n_levels))
76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L281-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.@string2formula-Tuple{Any}" href="#GBCore.@string2formula-Tuple{Any}"><code>GBCore.@string2formula</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@string2formula(x::String)</code></pre><p>Convert a string representation of a formula into a <code>Formula</code> object.</p><p>This macro parses a string containing a formula expression and evaluates it into a proper <code>Formula</code> object that can be used in statistical modeling.</p><p><strong>Arguments</strong></p><ul><li><code>x::String</code>: A string containing the formula expression (e.g., &quot;y ~ x + z&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>Formula</code>: A Formula object representing the parsed expression</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/tebv.jl#L262-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.@stringevaluation-Tuple{Any}" href="#GBCore.@stringevaluation-Tuple{Any}"><code>GBCore.@stringevaluation</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@stringevaluation(x)</code></pre><p>Parse and evaluate a string expression at compile time.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A string containing a Julia expression to be parsed.</li></ul><p><strong>Returns</strong></p><ul><li>The parsed expression as an <code>Expr</code> object ready for evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBCore.jl/blob/7aaffff1bde5837ce18ec5e0a22b798f541779f4/src/phenomes.jl#L891-L901">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Tuesday 18 March 2025 03:26">Tuesday 18 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
